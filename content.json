{"posts":[{"title":"踩雷系列：%E2%80%8B 神奇的空白","text":"此篇文章同時收錄在我的 Medium 中，之後都會統一更新在 Hexo 這邊囉！ 事情是這樣發生的…上週和後端工程師開始進行專案的協作時，他提供了一份 Swagger UI 的文件讓我們做 API 的介接。一開始我就像撰寫其他專案一樣，將 Swagger UI 文件內所有的 API 統一複製貼上到 All.js 的檔案中，並在需要使用的頁面來介接。不過就在使用第一個 GET 的 API 時就出現 status 404 的狀況： 問題出在？ 通常出現 4 開頭的 status code 我就會確定是 client 端的問題，於是我就開始檢查我的 API URL 還有 axios 介接的方法有沒有寫錯？不過怎麼檢查程式碼和檢視 nuxt 的撰寫方式後都看不出來哪邊有問題和狀況？所以我就回頭看看 Console 視窗內的這個錯誤訊息，這才發現到一個很詭異的地方： 咦？ URL 中間怎麼多了幾個 %E2%80%8B 的字串？ 起初想說是不是 URL 自動將我的斜線編譯成 Unicode 了 ? 不過我又在 %E2%80%8B 後面看到了 / ，所以我就直接將 %E2%80%8B 這個字串丟到 Google 上去看了一下，究竟這是什麼鬼東西？ %E2%80%8B is the code for a “ZERO-WIDTH SPACE” character. 好！這下直接解開謎團了，原來是一個叫做 Zero-width space 的字元，中文翻譯也很直白，就叫做「零寬空格」。所以就如同字面上的意思，它是不會顯示出間隔的空格（怎麼有點饒口？） 使用 JS 的 decodeURI 將該編譯字元解碼後，可以看到解碼過後的空字串大家應該可以更加理解到什麼叫做「零寬空格」了吧？所以知道問題出在哪邊之後就開始著手更改這些因為懶得自己打的 API URL 而報錯的狀況了 解決方法如果專案內沒有太多的 API 那你可以先將複製貼上的 URL 移除後，再自行手動輸入即可（不要再偷懶ㄌ）。不過如果是像我一樣一次大量的複製貼上的你，那就只能用程式碼來解決了 1url = decodeURI(encodeURI(url).replace(/%E2%80%8B/g, '')) 記得在發送 Request 之前，將 URL 中的零寬空格使用空字串來取代。 後記後來在找解決方法的時候，確實在 Stack Overflow 上看到很多從 Swagger UI 文件上複製貼上 URL 的開發者也遇到相同的問題。也有蠻多人感嘆剛開始遇到這個問題真的百思不得其解？還跟後端對了好多次，透過 POSTMAN 等工具確認 API 介接都是正常無誤的，最後發現是這個問題的時候簡直傻眼的人也是不少。不過很幸運自己是在和後端求救之前有先找到問題點在哪的？ 開發的日子久了，什麼奇怪的 Bug 都能遇到呢 這系列果然算是蠻快就更新了希望大家很不幸遇到這個坑的時候可以馬上找到我這篇文章！那我們下次再見ʘ‿ʘ 參考資料菜雞抓蟲: Url 變得怪怪的？你可能是零寬空格（ZWSP）的受害者！ - 伊果的沒人看筆記本","link":"/2022/11/28/blank-space-debug/"},{"title":"終於建好了！我的 Hexo 技術部落格","text":"這是我的技術部落格的第一篇文章！實在是太感人了！講了好久的部落格一直都停留在想法的階段，但卻沒有真的去執行，直到前幾天發現了好多前端的前輩們都使用這個 Hexo 的套件快速建立網站後就決定著手開始了。 為什麼會想要建立技術部落格？其實最一開始我都是使用自己的 Notion 來做前端技術的筆記撰寫並建立起自己的技術資料庫，當初確實也有想過是否要將自己的筆記公開來，但是心中卻產生了一種如果我寫的是錯的怎麼辦？如果我誤人子弟怎麼辦？不過最後是在洧杰的一句話裡直接茅塞頓開： 想太多了吧！根本就不會有人看你的文章啦～ 所以就決定開始在自己的 Medium 發表一些技術文章和筆記，試著將自己學習的技術內容做紀錄，但也陸續發現關於 Medium 這個平台的一些狀況還有我個人的心理因素（又來！ Medium在 Medium 寫了幾篇文章後，確實有被一些人看到和獲得了拍手鼓勵，所以一開始是還蠻有成就感的。但是我漸漸發現該平台比較多英語使用者，加上大部分中文的文章也都屬於品質比較好的技術內容。 於是我漸漸發現，像是自己寫的這種筆記類型的文章好像不那麼適合在這個平台發布，所以就開始想說要自己建立一個技術部落格了。 自己架設部落格有了想要自己架設部落格的想法之後，就開始萌生出了許多要考量的點，像是： 網站的 UI 要設計成什麼樣子？ 需要有什麼功能方便使用者瀏覽文章？ 文章寫好之後要用什麼資料格式存放？ 整個部落格應該要放在哪個伺服器服務？ 想了一想，覺得這麼多東西要安排和規劃，那之後再說吧～ 對！就是這句之後再說吧的話就讓這個部落格計畫完全停滯不前，因為光想到上面列的那幾個問題就提不起勁要開工了 QQ 所幸在前幾天意外看到了 Ray 的鐵人賽文章 試著學 Hexo 後，才終於下定決心要來試著架設自己的技術部落格了。 Hexo於是照著鐵人賽文章裡面的內容開始安裝了 Hexo 並且逐步的將自己的部落格建立了起來，也意外發現其實蠻多前輩都是使用這個服務在撰寫自己的技術文章的。而且有了技術部落格之後內心突然覺得很踏實，終於有一個可以讓自己放心紀錄的平台了！ 關於部落格之後的走向？有大概想了一下這個部落格要發表的內容，不過其實不太想全部都侷限於技術的東西，有時候一直追技術也是頗累的XD所以之後應該會按照著這幾個大項目來做技術和其他日常的文章撰寫： 預計有的 Categories 技術文章系列：舉凡任何的框架、工具或程式語言的專門技術文章 踩雷系列：紀錄自己開發過程中遇到的 Bug 並祈禱不要太多人剛好需要這篇文章 SuoChan：紀錄身為前端工程師的日常或是一些心路歷程 目前想到的大項就是這三點了，或許之後會再新增也不一定？ 期許簡而言之，希望建立好這個部落格之後自己能慢慢的重回到渴望學習新技術和工具的狀態。 然後這篇文章沒有要教大家怎麼架設自己 Hexo 部落格喔！之後確實會透過文章紀錄我是怎麼從無到有建立的，但如果已經等不及的話可以先參考上面 Ray 的鐵人賽文章。 參考資料 試著學 Hexo 系列 Markdown 教學","link":"/2022/11/05/personasl-hexo-blog/"},{"title":"React.js 學習記錄：什麼是 React.js ?","text":"此篇文章同時收錄在我的 鐵人賽文章 - React.js 30 天學習全記錄 中，之後會同步更新在 Hexo 這邊唷！ 我自己在學習新技術的時候比較習慣先暸解一下這個技術的基本概念還有它解決了什麼問題。所以今天我要跟大家一起來看 React.js 到底是什麼？它又能夠幫我們做什麼呢？ 什麼是 React.js ? A JavaScript library for building user interfaces. 沒錯！從官網進去後，印入眼簾的就是這段話。所以 React.js 其實就是一個用來打造 UI 的 JavaScript 函式庫，而且它是由 Facebook 團隊所開發出來的。在 Facebook Open Source 中不只有 React.js 而已，現今撰寫 APP 常用到的框架 React Native 也是由他們所開發的（在 Facebook Open Source 的網站中可以瀏覽其他由該團隊開發的框架和函式庫）。 框架 Framework？ 函式庫 Library？隨著網頁開發的功能越來越多元、內容也越來越複雜後，工程師們為了解決開發上衍生出的種種問題而寫出解決這些狀況的框架和函式庫。不過看了那麼多資料跟介紹不斷地提及框架和函式庫，我真的每次都被搞得頭昏眼花。結果就在搜集資料和瀏覽文章的時候看到了這篇文章仔細地分析了究竟這兩者的差別在哪？ 差異在於，使用「框架」的話，框架具有控制權，而身為這份軟體的開發者，你需要依照框架的設計把功能填上，填完的之後，程式便會照你的意思運作了；「函式庫」則是不同的，它像是一個彈藥庫，裡面藏有各種武器供你使用，你有控制權去決定怎麼使用它們，甚至不使用。 看完這段敘述之後我們大概可以了解這兩者之間的差異了吧？想想看以前在練習 Side Project 的時候如果遇到不會的功能，可能會去 CodePen 上面找看看別人的範例。而這些範例當中會有些人在特定的地方使用到 jQuery 這個 函式庫 (library) 但是並不一定所有的內容都會使用到（可能一部分是寫原生的 JavaScript ）。不過當你是使用 Vue.js 這個 框架 (Framework) 的時候，就是必須按照它設定好的環境來撰寫特定的語法來開發整個功能。 所以你有發現一件事情嗎？在你見過的大多數資料內所提及目前的前端三大框架 Angular 、 Vue.js 以及 React.js 中， 其實有一個根本就不是框架而是函式庫，它就是 React.js ！ React.js 可以解決什麼問題？透過上面的內容我們現在對 React.js 可以說是有初步的認識了，但是所有的工具（不管是框架或函式庫）被開發出來都是為了要解決問題，讓我們能夠更便利更快速地進行前端開發。講了這麼多，所以 React.js 到底提供了哪些功能來幫助我們呢？ 要了解它能幫你解決什麼問題前，你其實應該先問問自己一個問題：在最一開始學習 JavaScript 做前端開發時遇到了哪些狀況？ 這邊先列幾個我曾經寫原生 JavaScript 寫到懷疑人生的時候遇到的狀況給大家作為參考： 設定很多 DOM ，光想命名就崩潰。之後除了要監聽事件，還要注意綁定的 DOM 是否正確？否則也監聽不到。 不斷地在渲染(Render)畫面。如果要渲染的區塊比較多資料的話，程式碼就會看起來又臭又長。 有些功能類似的開發，因為資料還是有些微的不一樣就一直重複撰寫相似的內容。 以上就是我目前想到當初在使用原生 JavaScript 開發的時候遇到的難處和困擾。當然我相信這不會是只有我一個人遇到的狀況，所以這些開發困境也是讓後來許許多多的 JavaScript 框架和函式庫不斷出現的原因。 所以知道自己的問題在哪之後，我們就來看看 React.js 這個函式庫究竟提供了什麼樣的方法來幫助我們脫離上面的種種困境呢？ React.js 的兩大特色 宣告式 Declarative 在 React.js 中的 View 是採用宣告的方式並使用 Virtual DOM 的概念來進行綁定和渲染。它會在資料有變更時更有效率的自動更新並渲染 （Render） 所有有產生變動的元件。簡單來說，這代表當我的資料或內容有更新的時候，我不再需要去重新渲染出整個區塊的資料，而是透過宣告式的 View 來直接幫我更新畫面上那些有變更的資料而且需要重新渲染的部分即可。 所以這部分就解決了我們前面提到不斷的再重新渲染頁面的問題了。 元件式開發 Component-Based React.js 是以 元件為基礎 來做開發的，因此你可以自行定義不同的元件並設定每個元件不同的狀態（state），以及透過傳送給子元件（props）的方式來進行資料的傳遞。而基於這樣的元件基礎開發模式之下，我們就可以將網站中會重複利用的東西（像是按鈕等）定義成一個元件，並針對不同用途或功能去做設定資料（像是按鈕上面的文字）。 所以這部分則是解決了原生 JavaScript 在開發上會重複撰寫相同功能但是不同資料的東西，大大的簡化程式碼之外也提升了可閱讀性和之後要修改的便利性。 以上都是 React.js 為我們提供的強大功能，不過還有很多等著我們探索的地方，所以就繼續讀下去吧！另外有任何問題都非常非常歡迎提出和指教唷～那我們下篇見ʘ‿ʘ","link":"/2023/01/22/reactjs-learning-whats-framework-library/"},{"title":"Vue.js : v-on 事件綁定指令","text":"v-on 是一個 Vue.js 的事件指令，是用來綁定在 DOM 上做為事件監聽和執行指定函式的功能。 v-on 的實作v-on 的寫法為 v-on:事件名稱=”執行的函式” ，其實這就等同於我們使用 JavaScript 所撰寫的 querySelector 以及 addEventListener 這兩個功能。 JavaScript 寫法12// HTML&lt;button class=&quot;btn-add&quot; /&gt; 123// JavaScriptconst addButton = document.querySelector('.btn-add');addButton.addEventListener('click', count++) 先在 HTML 建立 class 或是 id 名稱（建議使用 class 名稱），並在 JavaScript 的檔案中綁定指定的 DOM 的 class 或是 id 名稱後再使用 addEventListener 來監聽指定的 click 事件，並執行 count++ 這個函式。 v-on 寫法1234&lt;template&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;button class=&quot;btn-add&quot; v-on:click=&quot;count++&quot; /&gt;&lt;/template&gt; 直接在要綁定監聽事件的 DOM 上使用 v-on 的指令之後，加上要監聽的事件名稱和要執行的函式即可。 v-on 的簡寫實務上不大會使用 v-on:事件名稱=”執行的函式” 這樣的寫法，比較常使用的是 @事件名稱=”執行的函式” （貫徹工程師能省則省的簡單寫法）。 1234&lt;template&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;button class=&quot;btn-add&quot; @click=&quot;count++&quot; /&gt;&lt;/template&gt;","link":"/2023/01/04/vuejs-von-directive/"}],"tags":[{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"Swagger","slug":"Swagger","link":"/tags/Swagger/"},{"name":"BlankSpace","slug":"BlankSpace","link":"/tags/BlankSpace/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"空白","slug":"空白","link":"/tags/%E7%A9%BA%E7%99%BD/"},{"name":"PersonalStuff","slug":"PersonalStuff","link":"/tags/PersonalStuff/"},{"name":"React.js","slug":"React-js","link":"/tags/React-js/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"},{"name":"Learning","slug":"Learning","link":"/tags/Learning/"},{"name":"FrontEnd","slug":"FrontEnd","link":"/tags/FrontEnd/"},{"name":"Note","slug":"Note","link":"/tags/Note/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"VueDirective","slug":"VueDirective","link":"/tags/VueDirective/"},{"name":"事件綁定","slug":"事件綁定","link":"/tags/%E4%BA%8B%E4%BB%B6%E7%B6%81%E5%AE%9A/"},{"name":"指令","slug":"指令","link":"/tags/%E6%8C%87%E4%BB%A4/"},{"name":"v-on","slug":"v-on","link":"/tags/v-on/"}],"categories":[{"name":"Debug Series","slug":"Debug-Series","link":"/categories/Debug-Series/"},{"name":"SuoChan&#39;s Log","slug":"SuoChan-s-Log","link":"/categories/SuoChan-s-Log/"},{"name":"React.js 28days Notes","slug":"React-js-28days-Notes","link":"/categories/React-js-28days-Notes/"},{"name":"Vue.js","slug":"Vue-js","link":"/categories/Vue-js/"}],"pages":[{"title":"","text":"google-site-verification: google2e6edbdffdf9e909.html","link":"/google2e6edbdffdf9e909.html"}]}