{"posts":[{"title":"20230724 log - Vimium","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點由於前公司有使用 Vim 的指令和操作，因此後來在自己的 IDE 和 Kata 練習的時候都會改成使用 Vim 的模式來撰寫程式碼。在還沒真正使用 Vim 之前完全搞不懂為何有人要特別去學習這種上古世代的指令，而且學習成本也高。不過在體會能夠快速透過 Vim 語法實現產品邏輯的時候才體會到了它的好。也真的是沒想過自己還會開始尋找 Vim 相關的套件或者是工具，實在很有趣！ 所以今天是來介紹我找到的一個 google 套件，叫做 Vimium - 一個可以在 google chrome 上面使用 Vim 的指令來瀏覽網頁的套件。 下面的參考資料會附上這個套件下載的網址，該套件的首頁是有作者親自錄製的常用快捷鍵導覽，基本上和我們使用 Vim 的指令是大致相同的，如果大家對 Vim 的指令有興趣的話，我可以再來整理。 雖然昨天才剛下載好，不過很明顯感受到自己使用滑鼠的頻率大幅降低了，整體感受挺不錯的，大家可以自己下載來試試看喔！ 參考資料 Vimium 下載網址 如何提升鍵盤的使用效率？Vimium 讓你不用滑鼠，只使用鍵盤瀏覽與控制網頁","link":"/2023/07/24/20230724-log/"},{"title":"20230726 log - Web Security","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點最近透過以前追蹤的一些軟體開發者的分享，開始對於資安的相關領域越來越有興趣。所以這幾天就是開始尋找一些比較入門的文章，看有沒有比較適合初學者的學習路徑和內容？ 不過除了開始對新的領域產生好奇外，也會有點擔心前端以及今年上半年主力研究的後端是不是需要先擱置在一旁？感覺自己踏入了這個軟體開發的領域之後就時不時的產生這樣子的焦慮，深怕自己一個不小心就被產業變遷的速度給沖走了。 但現階段來說，可能因為今年是相對變動比較大的 – 不管是喜或憂的部分，所以還是會希望能夠找到一個自己能夠真正的發揮所長或長才的舞台，因此這樣的擔憂出現確實也是有它的原因存在。 預計下週開始會整理一些資安相關的文章資源在這，那就下週再來更新囉！","link":"/2023/07/27/20230726-log/"},{"title":"20230731 log","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點今天整理了一些資安相關的鐵人賽文章以及網路上的優文分享給大家，除了補充一點資安相關的知識以外，其實也打算把這樣的概念融入到自己新的 side project 中。 另外針對新的 side project 也想加入 unit test 至其中，但目前尚未有實際使用過的經驗，所以預計這週會花點時間琢磨在 unit test 相關的 framework 來好好的比較一下，最後再來決定要使用哪一個？ 參考資料 生活資安五四三！從生活周遭看風險與資訊安全～番外篇 資安x系統x絕對領域 [很不鐵人的 IT 鐵人賽] 前端工程師學資訊安全","link":"/2023/07/31/20230731-log/"},{"title":"20230804 log - Web Check","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點今天跟大家分享我在 Twitter ( 現名為 X ) 看到的一個網站檢測工具 - Web Check , 你可以在 input 的欄位裡輸入您想調查的網址，就可以知道該網域目前的機台所在地和該網站所使用的技術和資安相關設定的項目。 附圖是 Web Check 的畫面 大家可以試著貼上自己的網站或是好奇的網站來看看，挺有趣的！ 參考資料 Web Check Web Check GitHub","link":"/2023/08/04/20230804-log/"},{"title":"20230816 log - Vue3 and React todolist","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點這週讀書會跟大家討論一下接下來要學習的路徑，最後決定一起來學 TypeScript 了。雖然在前公司開發的時候是使用 Vue3 + TypeScript 沒錯，不過實際接觸到開發的功能其實沒有使用到邏輯的撰寫，所以嚴格來說對於 TypeScript 的理解還處於很基礎的程度。 這邊預計是下週讀書會的時候要一起分享各自寫的 Vue3 + TypeScript 的 todolist 寫法，有包含基本的 CRUD 還有 Done 的 filter 功能等。完成後就在更新到這邊來給大家參考吧！ 參考資料 我的 GitHub Repository","link":"/2023/08/31/20230816-log-Testing-tools/"},{"title":"20230802 log - 個人作品網站實作規劃","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點這幾天看到大家推薦要練習一個工具或是實作一個功能的話建議還是做一個簡易的專案來從中學習，所以明後兩天是規劃要先練習 React 的 Todolist 之後，再使用 React 實作一個個人的作品網站。 目前預計要使用在個人的作品網站的技術有以下幾個： i18n 多國語系 night mode 的模式切換 Unit test ( Vitest / Playwright) animation.js CI/CD (GitHub Actions) 以上是目前預計要使用到的技術或工具，至少身為一個網頁軟體工程師我覺得上述的這幾個功能算是蠻基礎且必要的。接下來幾天就陸續跟大家更新我的實作進度囉！","link":"/2023/08/02/20230802-log/"},{"title":"20230901 log - C# workshop","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點前幾天在 FB 上看到這個 C# 的官方挑戰課程，剛好在練習了 kata 完之後可以接續這個內容。目前計畫是在自己生日之前要完成這個學習計畫，也期許自己能慢慢的朝全端之路前進，今天會是學習計畫的第一天，如果大家對這個課程有興趣的話我將上課的連結提供在下方。 P.S 這個課程是 Micosoft 官方所推出的，要上課前要記得先註冊一個 Microsoft 的帳號唷！ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/2023/09/01/20230901-log-C-workshop/"},{"title":"C# Challenge - 撰寫您的第一個 C# 程式碼","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第一單元章節的內容。 單元重點今天完成了 Microsoft 的 challenge 第一單元，基本上沒有太多的知識量，介紹了 C# 這個程式語言的基本知識還有編譯器的作用是什麼等等。 不過硬要指出一個缺點的話就是這個 challenge 有一些頁面或是課程的翻譯是用機器或 AI 翻譯的，所以在一些課程的說明文件和問答的語意上會呈現比較不能理解的意思。但沒有到太影響到我的學習，所以整體來說還是算可以的，可是畢竟我目前只有上了一個單元，之後可能還要再陸續觀察一下其他單元的狀況。 一樣把上課的連結放在參考資料裡面，有興趣的大家可以自己去報名參加喔！ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/2023/09/06/C-01-course/"},{"title":"防抖 ( Debounce ) 和節流 ( Thorttle )","text":"會找到這篇文章的你，應該是在近期聽到了這兩個名詞對吧？我其實是在上週的面試過程中被問到了這個對當時的我來說非常陌生的兩個詞。一起來看什麼是 JS 的防抖和節流吧！ 名詞介紹開門見山的說，這兩種方法其實都是為了降低網頁在短時間內重複觸發 Function 太多次所造成的效能浪費，所以簡而言之他們的出現其實就是 防抖 Debounce什麼是防抖 Debounce ?實際應用範例節流 Thorttle什麼是節流 Thoorttle ?實際應用範例結論","link":"/2023/09/13/JavaScript-Debounce-and-Thorttle/"},{"title":"踩雷系列：%E2%80%8B 神奇的空白","text":"此篇文章同時收錄在我的 Medium 中，之後都會統一更新在 Hexo 這邊囉！ 事情是這樣發生的…上週和後端工程師開始進行專案的協作時，他提供了一份 Swagger UI 的文件讓我們做 API 的介接。一開始我就像撰寫其他專案一樣，將 Swagger UI 文件內所有的 API 統一複製貼上到 All.js 的檔案中，並在需要使用的頁面來介接。不過就在使用第一個 GET 的 API 時就出現 status 404 的狀況： 問題出在？ 通常出現 4 開頭的 status code 我就會確定是 client 端的問題，於是我就開始檢查我的 API URL 還有 axios 介接的方法有沒有寫錯？不過怎麼檢查程式碼和檢視 nuxt 的撰寫方式後都看不出來哪邊有問題和狀況？所以我就回頭看看 Console 視窗內的這個錯誤訊息，這才發現到一個很詭異的地方： 咦？ URL 中間怎麼多了幾個 %E2%80%8B 的字串？ 起初想說是不是 URL 自動將我的斜線編譯成 Unicode 了 ? 不過我又在 %E2%80%8B 後面看到了 / ，所以我就直接將 %E2%80%8B 這個字串丟到 Google 上去看了一下，究竟這是什麼鬼東西？ %E2%80%8B is the code for a “ZERO-WIDTH SPACE” character. 好！這下直接解開謎團了，原來是一個叫做 Zero-width space 的字元，中文翻譯也很直白，就叫做「零寬空格」。所以就如同字面上的意思，它是不會顯示出間隔的空格（怎麼有點饒口？） 使用 JS 的 decodeURI 將該編譯字元解碼後，可以看到解碼過後的空字串大家應該可以更加理解到什麼叫做「零寬空格」了吧？所以知道問題出在哪邊之後就開始著手更改這些因為懶得自己打的 API URL 而報錯的狀況了 解決方法如果專案內沒有太多的 API 那你可以先將複製貼上的 URL 移除後，再自行手動輸入即可（不要再偷懶ㄌ）。不過如果是像我一樣一次大量的複製貼上的你，那就只能用程式碼來解決了 1url = decodeURI(encodeURI(url).replace(/%E2%80%8B/g, '')) 記得在發送 Request 之前，將 URL 中的零寬空格使用空字串來取代。 後記後來在找解決方法的時候，確實在 Stack Overflow 上看到很多從 Swagger UI 文件上複製貼上 URL 的開發者也遇到相同的問題。也有蠻多人感嘆剛開始遇到這個問題真的百思不得其解？還跟後端對了好多次，透過 POSTMAN 等工具確認 API 介接都是正常無誤的，最後發現是這個問題的時候簡直傻眼的人也是不少。不過很幸運自己是在和後端求救之前有先找到問題點在哪的？ 開發的日子久了，什麼奇怪的 Bug 都能遇到呢 這系列果然算是蠻快就更新了希望大家很不幸遇到這個坑的時候可以馬上找到我這篇文章！那我們下次再見ʘ‿ʘ 參考資料菜雞抓蟲: Url 變得怪怪的？你可能是零寬空格（ZWSP）的受害者！ - 伊果的沒人看筆記本","link":"/2022/11/28/blank-space-debug/"},{"title":"16 進位 ( Hexadecimal Number System )","text":"今天要來紀錄一下在撰寫 API 的時候第一次聽到的名詞： 十六進制 Hexadecimal 什麼是十六進制（ Hexadecimal ）？ 十六進制（ Hexadecimal ），也叫十六進位或者簡稱為 Hex ，是一種數字系統。這個數字系統總共使用了 16 個符號來表示數字，分別為：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F 等 16 個符號。 在十六進制中，每個位數的值就是 16 的次方，而每個位數都可以使用上面所列出的 16 個符號來表示。 從 A 開始代表的值為 10 ， B 為 11 ，以此類推 F 則為 15。 範例介紹假設在十進制的數字 15 ，它就會等同於十六進制中的 F 符號（ F 代表的值是 15 ）。若是在十進制中的數字 16，換成十六進制的數字時則為 10 。 為什麼是 10 ?因為在十六進制中，數字 10 中的 1 代表的是 16 的 1 次方，再加上了右邊的 0 代表的是 16 的 0 次方，兩者相加就為 16 ，這就是十進位中的數值了。 應用場景為什麼會在開 API 的時候遇到這個名詞呢？最主要的原因就是當初在設定回傳的 response 中會使用到十六進制的計算方式來計算我們的 API 中所回傳的資料長度，因此才知道了這個名詞。後來才知道在計算機概論和數字系統中，很常使用十六進制來表示二進制的數字。因為每個十六進制的數字可以表示出更多單位的二進制數字，所以才應用在這個領域當中。","link":"/2023/03/06/hexadecimal-hexi/"},{"title":"踩雷系列：ICARUS 的樣式設定檔案在哪裡？","text":"在 Hexo 技術部落格建好之後，開始想要微調一些樣式設定（蠻喜歡 Medium 那種簡約的風格），所以開始搜尋要怎麼修改我使用的樣式 ICARUS ，下面就來跟大家分享一下設定的內容： ICARUS 的樣式設定檔案位置樣式的檔案是在 node_modules 的資料夾內，資料夾的路徑是 hexo-theme-icarus/include/style這邊會建議大家新增一個自己的樣式檔案並在裡面填寫你修改的內容，當然也可以直接修改原始的 ICARUS 的樣式檔案。 為什麼這篇是放在踩雷系列？沒錯！應該有人會困惑說這篇看起來沒有任何的雷啊？但是我在修改樣式的初期一直找不到 ICARUS 的樣式檔案在哪邊？甚至還跑去修改編譯過後的 CSS 檔案，所以理所當然的，樣式是不可能有調整。因此我確實花了一段時間找到了原來樣式設定的檔案們在哪邊？確實有點搞笑 XD希望有使用 Hexo 搭配 ICARUS 的大大們都不要像我一樣找超久 QQ 修改的內容這邊有參考了其他網站的設定教學，調整了旁邊的 sidebar 和文章區塊的比例，因為教學文章很詳細，所以會附在下方的參考資料給大家！ 那我們下次見ʘ‿ʘ 參考資料Hexo - Icarus 主題 - 內容區塊寬度","link":"/2023/02/08/icarus-style-file/"},{"title":"Kata Practice C# - DNA to RNA Conversion","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Deoxyribonucleic acid, DNA is the primary information storage molecule in biological systems. It is composed of four nucleic acid bases Guanine (‘G’), Cytosine (‘C’), Adenine (‘A’), and Thymine (‘T’). Ribonucleic acid, RNA, is the primary messenger molecule in cells. RNA differs slightly from DNA its chemical structure and contains no Thymine. In RNA Thymine is replaced by another nucleic acid Uracil (‘U’). Create a function which translates a given DNA string into RNA. For example: “GCAT” =&gt; “GCAU”The input string can be of arbitrary length - in particular, it may be empty. All input is guaranteed to be valid, i.e. each input string will only ever consist of ‘G’, ‘C’, ‘A’ and/or ‘T’. 自己的解法123456789namespace Converter { public class Converter { public string dnaToRna(string dna) { return dna.Replace('T','U'); } }} 解題脈絡按照問題的敘述先去 Google 找 C# 有沒有相對應的方法？於是就找到了 Replace 的這個方法，不過感覺這樣只是解決了基本的需求。當然這樣還是有符合題目的需求，但感覺應該還有更符合日常開發的狀況，所以就看了其他人的 Solution。 其他人的解法1234567891011121314namespace Converter { public class Converter { public string dnaToRna(string dna) { char[] dnaLetters = new char[4]{'G','C','A','T'}; string upperCaseDna = dna.ToUpper(); if(upperCaseDna.Any( letter =&gt; !dnaLetters.Contains(letter))) throw new ArgumentException(); return upperCaseDna.Replace('T','U'); } }} 選擇這個解法的原因雖然直接使用 Replace 可以完成需求，不過參考的這個 Solution 有將每一步的邏輯都整理起來，即便相較原本的寫法多了一些變數和判斷，但是這樣確有助於釐清整個程式碼的可讀性。即便不需要註解也可以知道這個 Class 在解決的問題是什麼？ 觀念釐清希望之後自己在練習 kata 的時候也能夠想到比較全面的練習，不僅僅是只符合題目的需求而已。","link":"/2023/05/18/kata-dna-to-rna-conversion/"},{"title":"終於建好了！我的 Hexo 技術部落格","text":"這是我的技術部落格的第一篇文章！實在是太感人了！講了好久的部落格一直都停留在想法的階段，但卻沒有真的去執行，直到前幾天發現了好多前端的前輩們都使用這個 Hexo 的套件快速建立網站後就決定著手開始了。 為什麼會想要建立技術部落格？其實最一開始我都是使用自己的 Notion 來做前端技術的筆記撰寫並建立起自己的技術資料庫，當初確實也有想過是否要將自己的筆記公開來，但是心中卻產生了一種如果我寫的是錯的怎麼辦？如果我誤人子弟怎麼辦？不過最後是在洧杰的一句話裡直接茅塞頓開： 想太多了吧！根本就不會有人看你的文章啦～ 所以就決定開始在自己的 Medium 發表一些技術文章和筆記，試著將自己學習的技術內容做紀錄，但也陸續發現關於 Medium 這個平台的一些狀況還有我個人的心理因素（又來！ Medium在 Medium 寫了幾篇文章後，確實有被一些人看到和獲得了拍手鼓勵，所以一開始是還蠻有成就感的。但是我漸漸發現該平台比較多英語使用者，加上大部分中文的文章也都屬於品質比較好的技術內容。 於是我漸漸發現，像是自己寫的這種筆記類型的文章好像不那麼適合在這個平台發布，所以就開始想說要自己建立一個技術部落格了。 自己架設部落格有了想要自己架設部落格的想法之後，就開始萌生出了許多要考量的點，像是： 網站的 UI 要設計成什麼樣子？ 需要有什麼功能方便使用者瀏覽文章？ 文章寫好之後要用什麼資料格式存放？ 整個部落格應該要放在哪個伺服器服務？ 想了一想，覺得這麼多東西要安排和規劃，那之後再說吧～ 對！就是這句之後再說吧的話就讓這個部落格計畫完全停滯不前，因為光想到上面列的那幾個問題就提不起勁要開工了 QQ 所幸在前幾天意外看到了 Ray 的鐵人賽文章 試著學 Hexo 後，才終於下定決心要來試著架設自己的技術部落格了。 Hexo於是照著鐵人賽文章裡面的內容開始安裝了 Hexo 並且逐步的將自己的部落格建立了起來，也意外發現其實蠻多前輩都是使用這個服務在撰寫自己的技術文章的。而且有了技術部落格之後內心突然覺得很踏實，終於有一個可以讓自己放心紀錄的平台了！ 關於部落格之後的走向？有大概想了一下這個部落格要發表的內容，不過其實不太想全部都侷限於技術的東西，有時候一直追技術也是頗累的XD所以之後應該會按照著這幾個大項目來做技術和其他日常的文章撰寫： 預計有的 Categories 技術文章系列：舉凡任何的框架、工具或程式語言的專門技術文章 踩雷系列：紀錄自己開發過程中遇到的 Bug 並祈禱不要太多人剛好需要這篇文章 SuoChan：紀錄身為前端工程師的日常或是一些心路歷程 目前想到的大項就是這三點了，或許之後會再新增也不一定？ 期許簡而言之，希望建立好這個部落格之後自己能慢慢的重回到渴望學習新技術和工具的狀態。 然後這篇文章沒有要教大家怎麼架設自己 Hexo 部落格喔！之後確實會透過文章紀錄我是怎麼從無到有建立的，但如果已經等不及的話可以先參考上面 Ray 的鐵人賽文章。那我們下次見ʘ‿ʘ 參考資料 試著學 Hexo 系列 Markdown 教學","link":"/2022/11/05/personasl-hexo-blog/"},{"title":"React.js 學習記錄：什麼是 React.js ?","text":"此篇文章同時收錄在我的 鐵人賽文章 - React.js 30 天學習全記錄 中，之後會同步更新在 Hexo 這邊唷！ 我自己在學習新技術的時候比較習慣先暸解一下這個技術的基本概念還有它解決了什麼問題。所以今天我要跟大家一起來看 React.js 到底是什麼？它又能夠幫我們做什麼呢？ 什麼是 React.js ? A JavaScript library for building user interfaces. 沒錯！從官網進去後，印入眼簾的就是這段話。所以 React.js 其實就是一個用來打造 UI 的 JavaScript 函式庫，而且它是由 Facebook 團隊所開發出來的。在 Facebook Open Source 中不只有 React.js 而已，現今撰寫 APP 常用到的框架 React Native 也是由他們所開發的（在 Facebook Open Source 的網站中可以瀏覽其他由該團隊開發的框架和函式庫）。 框架 Framework？ 函式庫 Library？隨著網頁開發的功能越來越多元、內容也越來越複雜後，工程師們為了解決開發上衍生出的種種問題而寫出解決這些狀況的框架和函式庫。不過看了那麼多資料跟介紹不斷地提及框架和函式庫，我真的每次都被搞得頭昏眼花。結果就在搜集資料和瀏覽文章的時候看到了這篇文章仔細地分析了究竟這兩者的差別在哪？ 差異在於，使用「框架」的話，框架具有控制權，而身為這份軟體的開發者，你需要依照框架的設計把功能填上，填完的之後，程式便會照你的意思運作了；「函式庫」則是不同的，它像是一個彈藥庫，裡面藏有各種武器供你使用，你有控制權去決定怎麼使用它們，甚至不使用。 看完這段敘述之後我們大概可以了解這兩者之間的差異了吧？想想看以前在練習 Side Project 的時候如果遇到不會的功能，可能會去 CodePen 上面找看看別人的範例。而這些範例當中會有些人在特定的地方使用到 jQuery 這個 函式庫 (library) 但是並不一定所有的內容都會使用到（可能一部分是寫原生的 JavaScript ）。不過當你是使用 Vue.js 這個 框架 (Framework) 的時候，就是必須按照它設定好的環境來撰寫特定的語法來開發整個功能。 所以你有發現一件事情嗎？在你見過的大多數資料內所提及目前的前端三大框架 Angular 、 Vue.js 以及 React.js 中， 其實有一個根本就不是框架而是函式庫，它就是 React.js ！ React.js 可以解決什麼問題？透過上面的內容我們現在對 React.js 可以說是有初步的認識了，但是所有的工具（不管是框架或函式庫）被開發出來都是為了要解決問題，讓我們能夠更便利更快速地進行前端開發。講了這麼多，所以 React.js 到底提供了哪些功能來幫助我們呢？ 要了解它能幫你解決什麼問題前，你其實應該先問問自己一個問題：在最一開始學習 JavaScript 做前端開發時遇到了哪些狀況？ 這邊先列幾個我曾經寫原生 JavaScript 寫到懷疑人生的時候遇到的狀況給大家作為參考： 設定很多 DOM ，光想命名就崩潰。之後除了要監聽事件，還要注意綁定的 DOM 是否正確？否則也監聽不到。 不斷地在渲染(Render)畫面。如果要渲染的區塊比較多資料的話，程式碼就會看起來又臭又長。 有些功能類似的開發，因為資料還是有些微的不一樣就一直重複撰寫相似的內容。 以上就是我目前想到當初在使用原生 JavaScript 開發的時候遇到的難處和困擾。當然我相信這不會是只有我一個人遇到的狀況，所以這些開發困境也是讓後來許許多多的 JavaScript 框架和函式庫不斷出現的原因。 所以知道自己的問題在哪之後，我們就來看看 React.js 這個函式庫究竟提供了什麼樣的方法來幫助我們脫離上面的種種困境呢？ React.js 的兩大特色 宣告式 Declarative 在 React.js 中的 View 是採用宣告的方式並使用 Virtual DOM 的概念來進行綁定和渲染。它會在資料有變更時更有效率的自動更新並渲染 （Render） 所有有產生變動的元件。簡單來說，這代表當我的資料或內容有更新的時候，我不再需要去重新渲染出整個區塊的資料，而是透過宣告式的 View 來直接幫我更新畫面上那些有變更的資料而且需要重新渲染的部分即可。 所以這部分就解決了我們前面提到不斷的再重新渲染頁面的問題了。 元件式開發 Component-Based React.js 是以 元件為基礎 來做開發的，因此你可以自行定義不同的元件並設定每個元件不同的狀態（state），以及透過傳送給子元件（props）的方式來進行資料的傳遞。而基於這樣的元件基礎開發模式之下，我們就可以將網站中會重複利用的東西（像是按鈕等）定義成一個元件，並針對不同用途或功能去做設定資料（像是按鈕上面的文字）。 所以這部分則是解決了原生 JavaScript 在開發上會重複撰寫相同功能但是不同資料的東西，大大的簡化程式碼之外也提升了可閱讀性和之後要修改的便利性。 以上都是 React.js 為我們提供的強大功能，不過還有很多等著我們探索的地方，所以就繼續讀下去吧！另外有任何問題都非常非常歡迎提出和指教唷～那我們下篇見ʘ‿ʘ","link":"/2023/01/22/reactjs-learning-whats-framework-library/"},{"title":"Kata Practice C# - Opposites Attract","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Timmy &amp; Sarah think they are in love, but around where they live, they will only know once they pick a flower each. If one of the flowers has an even number of petals and the other has an odd number of petals it means they are in love. Write a function that will take the number of petals of each flower and return true if they are in love and false if they aren’t. 123456789using System;public class LoveDetector{ public static bool lovefunc(int flower1, int flower2) { //Moment of truth... }} 自己的解法123456789101112131415using System;public class LoveDetector{ public static bool lovefunc(int flower1, int flower2) { if( flower1 % 2 == 0 &amp;&amp; flower2 % 2 == 0 ){ return false; } else if ( flower1 % 2 != 0 &amp;&amp; flower2 % 2 != 0){ return false; } return true; }} 解題脈絡一開始就是照著題目的 Description 來寫，所以其實程式碼很直觀，但換個說法就是爛到不行哈哈！不過我覺得對於自己目前的程度來說就是盡量地用自己現有的思維去寫，然後再透過大家的 Solution 來學習別人寫程式的邏輯。可以備註的地方應該是在解題時我就有知道這樣的解法不是最佳解，這樣就是把所有的條件都各別列出來而已。 其他人的解法123456789using System;public class LoveDetector { public static bool lovefunc(int flower1, int flower2) { return (flower1 + flower2) % 2 == 1; } } 選擇這個解法的原因這邊的話會盡量選擇自己看得懂而且能夠理解的寫法來做紀錄，其實同樣的練習可能還有你認為更好的做法，那這部分你可以透過自己解題 Submit 後再去參考其他人的。會選擇這個解法的原因是 flower1 + flower2 如果被 2 取餘數是 1 的話就代表這兩個參數有一個不是雙數了，因此兩個雙數相加後取餘數就會等於 0 並符合題目要求的返回 False 的值。 觀念釐清後來發現是自己沒有搞清楚 % 這個算術運算子的功能其實是取餘數，所以才繞了一大圈把所有的條件都寫出來，雖然有點丟臉但不過現在也因此加深印象了 XD","link":"/2023/05/13/kata-opposites-attract/"},{"title":"33355 ? Scrum 中的第一個 3 - 三個角色","text":"這一篇要來跟大家分享的是基於 Agile 敏捷開發的 Scrum 框架中的 3 個角色有哪些？如果對於 Scrum 這個概念有點不是很了解的地方，之後會再另外整理一篇文章跟大家說明，這篇會著重在介紹究竟有哪些角色？他們分別又負責了哪些工作內容？讓我們繼續看下去 … Scrum 中的三個角色在執行 Scrum 的團隊當中，會有三個不同的角色執行不同的任務與職責來確保團隊的開發能夠順利地按照規劃來執行。那下面我們就來看一下這三個角色分別為何？ Product Owner 產品負責人通常在團隊中也會簡稱為英文單字的縮寫 PO ，下面就用 PO 代稱產品負責人。 PO 最主要的職責就是作為客戶與團隊之間的橋樑，需要瞭解客戶目前的需求以及期望獲得解決的方案等等，因此 PO 在釐清客戶需求的同時也必須確保開發團隊能夠確實知道客戶需要的功能或是服務是什麼？ 並且將每個需求的優先順序排列出來，讓開發團隊知道每個任務的優先順序是什麼以及為什麼？ PO 這個角色在我還沒有加入有導入 Scrum 的團隊時，我一直覺得這個職位和 PM 是相同的。不過在加入我們公司的 Scrum 團隊後發現 PO 對於客戶的需求必須有更進一步的理解，因為他必須能夠幫客戶判斷這個功能的優先程度是什麼？這樣開發團隊才能依照輕重緩急和順序來做開發，完成需要交付給客人的產品。 Development Team 開發團隊 在 Scrum 當中的開發團隊不只有軟體工程師，舉凡所有會跟開發工作相關的跨職能職位都會包含在這個團隊中，像是 UI 或是測試等項目都包含在其中。其職責最主要就是要順利完成每一次 Sprint 所設定目標 ( Sprint Goal )，並互相幫忙和提出意見以確保團隊都能一起解決定好的目標和問題。 在 Scrum 中的開發團隊會以 Team 的目標為首要任務，在這樣的團隊裡面不需要互相競爭比較，而是會將目光放到團隊要解決的問題上，變成一個以團隊為核心的概念。 Scrum Master唯一一個沒有翻譯成中文的角色，通常在團隊內都會直接稱做 Scrum Master 或是簡稱 SM ，下面就統一使用 SM 稱呼。 SM 就像是執行 Scrum 的教練，他會參與整個團隊的會議並且確保 Scrum 能夠順利的在團隊內執行，同時也會在過程當中給予一些會議流程或是方法上的改善與建議。 這邊要特別注意的是，雖然 SM 在團隊當中應該算是最透徹了解 Scrum 框架該怎麼執行的一個職位，不過在團隊中他僅能夠作為一個就他所觀察到的一些問題或是能夠優化的流程提出他專業意見的人，而要不要採納 SM 的建議以及解決方案則是決定在開發團隊本身，他並沒有權利叫團隊該如何進行會議或開發。 在公司內部有發現許多不同背景的人轉職成為 SM ，而不同背景出身的 SM 也會帶來許多不同的火花。像是我們團隊的 SM 就是從工程師背景轉過來的，因此他在提出一些想法和意見的時候就能夠用更貼近開發團隊的思維來提供，這點我個人覺得是一個蠻不錯的優勢。 SM 的職責還有這個職位實際上要點的技能樹有哪些？我還沒有完全的了解，之後再找時間把這塊知識給補上（或是請教 ChatGPT 好朋友） 結語接下來還會有四篇的文章來說明這個 Scrum 框架的口訣 33355 後面的四個數字分別代表什麼？有寫錯或是語意不通順還是不理解的部分歡迎大家踴躍留言，也感謝讀到這邊的各位大大，希望有為你們解惑唷！那我們下次見ʘ‿ʘ 參考資料 [DAY 09]角色設定01:Scrum三角色 一些產品負責人的怪味道 – 談Scrum Product Owner常見的誤區","link":"/2023/02/16/scrum-framework-three-roles/"},{"title":"Vue.js : v-on 事件綁定指令","text":"v-on 是一個 Vue.js 的事件指令，是用來綁定在 DOM 上做為事件監聽和執行指定函式的功能。 v-on 的實作v-on 的寫法為 v-on:事件名稱=”執行的函式” ，其實這就等同於我們使用 JavaScript 所撰寫的 querySelector 以及 addEventListener 這兩個功能。 JavaScript 寫法12// HTML&lt;button class=&quot;btn-add&quot; /&gt; 123// JavaScriptconst addButton = document.querySelector('.btn-add');addButton.addEventListener('click', count++) 先在 HTML 建立 class 或是 id 名稱（建議使用 class 名稱），並在 JavaScript 的檔案中綁定指定的 DOM 的 class 或是 id 名稱後再使用 addEventListener 來監聽指定的 click 事件，並執行 count++ 這個函式。 v-on 寫法1234&lt;template&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;button class=&quot;btn-add&quot; v-on:click=&quot;count++&quot; /&gt;&lt;/template&gt; 直接在要綁定監聽事件的 DOM 上使用 v-on 的指令之後，加上要監聽的事件名稱和要執行的函式即可。 v-on 的簡寫實務上不大會使用 v-on:事件名稱=”執行的函式” 這樣的寫法，比較常使用的是 @事件名稱=”執行的函式” （貫徹工程師能省則省的簡單寫法）。 1234&lt;template&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;button class=&quot;btn-add&quot; @click=&quot;count++&quot; /&gt;&lt;/template&gt; 那我們下次見ʘ‿ʘ","link":"/2023/01/04/vuejs-von-directive/"},{"title":"C# Challenge - 在 C# 中使用常值與變數值來儲存及擷取資料","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第二單元章節的內容。 課堂重點C# 型別 char：單一字元，在使用和宣告時是採用單引號的方式。 string：字串，在使用和宣告時是採用雙引號的方式。 int：整數，在使用和宣告時不需要採用特殊的方式，直接輸入數字即可。 浮點數：根據小數點的數目，再細分為三種類別 float: ~6-9 digits double: ~15-17 digits decimal: 28-29 digits，記得在數字的最後加上 m 或 M。 bool：布林值。 變數的命名規則 變數名稱可包含英數字元與底線字元。 不能使用井字號 # 或貨幣符號 $ 之類的特殊字元。 變數名稱的開頭必須是字母或底線，而不是數字。 變數名稱會區分大小寫，這表示 string Value; 與 string value; 是兩個不同的變數。 變數名稱不得為 C# 關鍵字。 例如：decimal decimal; 或 string string;。 var 關鍵字使用使用 var 關鍵字來宣告變數時，請務必初始化該變數的值，否則會看到 output 中的錯誤訊息。 單元重點主要注重在變數的資料型別以及該如何宣告，個人覺得 C# 的資料型別上在小數點跟字串的部分都更加的詳細，可能要花點時間適應。畢竟寫了太久的弱型別 JavaScript 實在不太習慣在宣告變數時就要加上型別的操作，但相信這絕對是個好的開發形貫的養成的！ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/2023/09/22/C-02-Challenge/"},{"title":"GraphQL 是什麼？ GraphQL &amp; RESTful API 的差異","text":"近幾個月求職的時候越來越常在 JD 和面試的時候被問到關於 GraphQL 的相關概念，所以就決定著手開始研究 GraphQL 究竟是什麼？它能應用到的場景是哪些？一起來一探究竟囉！","link":"/2023/09/22/graphql-restful-api-design/"},{"title":"NPM 更新後所有指令都失效了？ NPM 和 Node.js 版本號支援問題","text":"","link":"/2023/09/23/npm-node-version-error-problem-solution/"},{"title":"VSCode extension 遇到 Jumpy 和 Vim 的衝突事件","text":"踩雷系列全部的題材保證都是本人親自踩過的，希望各位如果剛好不幸遇到的話也能夠幸運的找到我的這篇文章幫你解惑！","link":"/2023/09/23/vscode-extension-vim-jumpy-solution/"}],"tags":[{"name":"Diary","slug":"Diary","link":"/tags/Diary/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"PersonalStuff","slug":"PersonalStuff","link":"/tags/PersonalStuff/"},{"name":"GoogleExtension","slug":"GoogleExtension","link":"/tags/GoogleExtension/"},{"name":"WebSecurity","slug":"WebSecurity","link":"/tags/WebSecurity/"},{"name":"E2E","slug":"E2E","link":"/tags/E2E/"},{"name":"Testing","slug":"Testing","link":"/tags/Testing/"},{"name":"UnitTest","slug":"UnitTest","link":"/tags/UnitTest/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"CodeCamp","slug":"CodeCamp","link":"/tags/CodeCamp/"},{"name":"Microsoft","slug":"Microsoft","link":"/tags/Microsoft/"},{"name":"Challenge","slug":"Challenge","link":"/tags/Challenge/"},{"name":"Certification","slug":"Certification","link":"/tags/Certification/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Debounce","slug":"Debounce","link":"/tags/Debounce/"},{"name":"Thorttle","slug":"Thorttle","link":"/tags/Thorttle/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"Swagger","slug":"Swagger","link":"/tags/Swagger/"},{"name":"BlankSpace","slug":"BlankSpace","link":"/tags/BlankSpace/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"空白","slug":"空白","link":"/tags/%E7%A9%BA%E7%99%BD/"},{"name":"Hexadecimal","slug":"Hexadecimal","link":"/tags/Hexadecimal/"},{"name":"Hexi","slug":"Hexi","link":"/tags/Hexi/"},{"name":"NumberingSystem","slug":"NumberingSystem","link":"/tags/NumberingSystem/"},{"name":"16進位","slug":"16進位","link":"/tags/16%E9%80%B2%E4%BD%8D/"},{"name":"CS","slug":"CS","link":"/tags/CS/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Style","slug":"Style","link":"/tags/Style/"},{"name":"Blogger","slug":"Blogger","link":"/tags/Blogger/"},{"name":"Kata","slug":"Kata","link":"/tags/Kata/"},{"name":"Codewars","slug":"Codewars","link":"/tags/Codewars/"},{"name":"KataPractice","slug":"KataPractice","link":"/tags/KataPractice/"},{"name":"Fundamentals","slug":"Fundamentals","link":"/tags/Fundamentals/"},{"name":"React.js","slug":"React-js","link":"/tags/React-js/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"},{"name":"Learning","slug":"Learning","link":"/tags/Learning/"},{"name":"FrontEnd","slug":"FrontEnd","link":"/tags/FrontEnd/"},{"name":"Note","slug":"Note","link":"/tags/Note/"},{"name":"Agile","slug":"Agile","link":"/tags/Agile/"},{"name":"Scrum","slug":"Scrum","link":"/tags/Scrum/"},{"name":"ScrumMaster","slug":"ScrumMaster","link":"/tags/ScrumMaster/"},{"name":"ProductOwner","slug":"ProductOwner","link":"/tags/ProductOwner/"},{"name":"DevelopementTeam","slug":"DevelopementTeam","link":"/tags/DevelopementTeam/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"VueDirective","slug":"VueDirective","link":"/tags/VueDirective/"},{"name":"事件綁定","slug":"事件綁定","link":"/tags/%E4%BA%8B%E4%BB%B6%E7%B6%81%E5%AE%9A/"},{"name":"指令","slug":"指令","link":"/tags/%E6%8C%87%E4%BB%A4/"},{"name":"v-on","slug":"v-on","link":"/tags/v-on/"},{"name":"WebDevelopment","slug":"WebDevelopment","link":"/tags/WebDevelopment/"},{"name":"GraphQL","slug":"GraphQL","link":"/tags/GraphQL/"},{"name":"RESTful","slug":"RESTful","link":"/tags/RESTful/"},{"name":"Design","slug":"Design","link":"/tags/Design/"},{"name":"NPM","slug":"NPM","link":"/tags/NPM/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"Version","slug":"Version","link":"/tags/Version/"},{"name":"Solution","slug":"Solution","link":"/tags/Solution/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"extension","slug":"extension","link":"/tags/extension/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"Jumpy","slug":"Jumpy","link":"/tags/Jumpy/"}],"categories":[{"name":"SuoChan&#39;s Log","slug":"SuoChan-s-Log","link":"/categories/SuoChan-s-Log/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Debug Series","slug":"Debug-Series","link":"/categories/Debug-Series/"},{"name":"CS Series","slug":"CS-Series","link":"/categories/CS-Series/"},{"name":"Kata Practice","slug":"Kata-Practice","link":"/categories/Kata-Practice/"},{"name":"React.js 30 Days","slug":"React-js-30-Days","link":"/categories/React-js-30-Days/"},{"name":"Scrum","slug":"Scrum","link":"/categories/Scrum/"},{"name":"Vue.js","slug":"Vue-js","link":"/categories/Vue-js/"},{"name":"C# Challenge","slug":"C-Challenge","link":"/categories/C-Challenge/"},{"name":"Web Development","slug":"Web-Development","link":"/categories/Web-Development/"}],"pages":[{"title":"","text":"google-site-verification: google2e6edbdffdf9e909.html","link":"/google2e6edbdffdf9e909.html"}]}