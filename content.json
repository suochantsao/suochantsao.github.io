{"posts":[{"title":"20230724 log - Vimium","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點由於前公司有使用 Vim 的指令和操作，因此後來在自己的 IDE 和 Kata 練習的時候都會改成使用 Vim 的模式來撰寫程式碼。在還沒真正使用 Vim 之前完全搞不懂為何有人要特別去學習這種上古世代的指令，而且學習成本也高。不過在體會能夠快速透過 Vim 語法實現產品邏輯的時候才體會到了它的好。也真的是沒想過自己還會開始尋找 Vim 相關的套件或者是工具，實在很有趣！ 所以今天是來介紹我找到的一個 google 套件，叫做 Vimium - 一個可以在 google chrome 上面使用 Vim 的指令來瀏覽網頁的套件。 下面的參考資料會附上這個套件下載的網址，該套件的首頁是有作者親自錄製的常用快捷鍵導覽，基本上和我們使用 Vim 的指令是大致相同的，如果大家對 Vim 的指令有興趣的話，我可以再來整理。 雖然昨天才剛下載好，不過很明顯感受到自己使用滑鼠的頻率大幅降低了，整體感受挺不錯的，大家可以自己下載來試試看喔！那我們下次見ʘ‿ʘ 參考資料 Vimium 下載網址 如何提升鍵盤的使用效率？Vimium 讓你不用滑鼠，只使用鍵盤瀏覽與控制網頁","link":"/2023/07/24/20230724-log/"},{"title":"20230726 log - Web Security","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點最近透過以前追蹤的一些軟體開發者的分享，開始對於資安的相關領域越來越有興趣。所以這幾天就是開始尋找一些比較入門的文章，看有沒有比較適合初學者的學習路徑和內容？ 不過除了開始對新的領域產生好奇外，也會有點擔心前端以及今年上半年主力研究的後端是不是需要先擱置在一旁？感覺自己踏入了這個軟體開發的領域之後就時不時的產生這樣子的焦慮，深怕自己一個不小心就被產業變遷的速度給沖走了。 但現階段來說，可能因為今年是相對變動比較大的 – 不管是喜或憂的部分，所以還是會希望能夠找到一個自己能夠真正的發揮所長或長才的舞台，因此這樣的擔憂出現確實也是有它的原因存在。 預計下週開始會整理一些資安相關的文章資源在這，就下週再來更新囉！那我們下次見ʘ‿ʘ","link":"/2023/07/27/20230726-log/"},{"title":"20230731 log","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點今天整理了一些資安相關的鐵人賽文章以及網路上的優文分享給大家，除了補充一點資安相關的知識以外，其實也打算把這樣的概念融入到自己新的 side project 中。 另外針對新的 side project 也想加入 unit test 至其中，但目前尚未有實際使用過的經驗，所以預計這週會花點時間琢磨在 unit test 相關的 framework 來好好的比較一下，最後再來決定要使用哪一個？那我們下次見ʘ‿ʘ 參考資料 生活資安五四三！從生活周遭看風險與資訊安全～番外篇 資安x系統x絕對領域 [很不鐵人的 IT 鐵人賽] 前端工程師學資訊安全","link":"/2023/07/31/20230731-log/"},{"title":"20230804 log - Web Check","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點今天跟大家分享我在 Twitter ( 現名為 X ) 看到的一個網站檢測工具 - Web Check , 你可以在 input 的欄位裡輸入您想調查的網址，就可以知道該網域目前的機台所在地和該網站所使用的技術和資安相關設定的項目。 附圖是 Web Check 的畫面 大家可以試著貼上自己的網站或是好奇的網站來看看，挺有趣的！那我們下次見ʘ‿ʘ 參考資料 Web Check Web Check GitHub","link":"/2023/08/04/20230804-log/"},{"title":"20230816 log - Vue3 and React todolist","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點這週讀書會跟大家討論一下接下來要學習的路徑，最後決定一起來學 TypeScript 了。雖然在前公司開發的時候是使用 Vue3 + TypeScript 沒錯，不過實際接觸到開發的功能其實沒有使用到邏輯的撰寫，所以嚴格來說對於 TypeScript 的理解還處於很基礎的程度。 這邊預計是下週讀書會的時候要一起分享各自寫的 Vue3 + TypeScript 的 todolist 寫法，有包含基本的 CRUD 還有 Done 的 filter 功能等。完成後就在更新到這邊來給大家參考吧！那我們下次見ʘ‿ʘ 參考資料 我的 GitHub Repository","link":"/2023/08/31/20230816-log-Testing-tools/"},{"title":"20230802 log - 個人作品網站實作規劃","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點這幾天看到大家推薦要練習一個工具或是實作一個功能的話建議還是做一個簡易的專案來從中學習，所以明後兩天是規劃要先練習 React 的 Todolist 之後，再使用 React 實作一個個人的作品網站。 目前預計要使用在個人的作品網站的技術有以下幾個： i18n 多國語系 night mode 的模式切換 Unit test ( Vitest / Playwright) animation.js CI/CD (GitHub Actions) 以上是目前預計要使用到的技術或工具，至少身為一個網頁軟體工程師我覺得上述的這幾個功能算是蠻基礎且必要的。接下來幾天就陸續跟大家更新我的實作進度囉！那我們下次見ʘ‿ʘ","link":"/2023/08/02/20230802-log/"},{"title":"20230901 log - C# workshop","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點前幾天在 FB 上看到這個 C# 的官方挑戰課程，剛好在練習了 kata 完之後可以接續這個內容。目前計畫是在自己生日之前要完成這個學習計畫，也期許自己能慢慢的朝全端之路前進，今天會是學習計畫的第一天，如果大家對這個課程有興趣的話我將上課的連結提供在下方。 P.S 這個課程是 Micosoft 官方所推出的，要上課前要記得先註冊一個 Microsoft 的帳號唷！ 那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/2023/09/01/20230901-log-C-workshop/"},{"title":"C# Challenge 01 -  撰寫您的第一個 C# 程式碼","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第一單元章節的內容。 單元重點今天完成了 Microsoft 的 challenge 第一單元，基本上沒有太多的知識量，介紹了 C# 這個程式語言的基本知識還有編譯器的作用是什麼等等。 不過硬要指出一個缺點的話就是這個 challenge 有一些頁面或是課程的翻譯是用機器或 AI 翻譯的，所以在一些課程的說明文件和問答的語意上會呈現比較不能理解的意思。但沒有到太影響到我的學習，所以整體來說還是算可以的，可是畢竟我目前只有上了一個單元，之後可能還要再陸續觀察一下其他單元的狀況。 一樣把上課的連結放在參考資料裡面，有興趣的大家可以自己去報名參加喔！那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/2023/09/06/C-01-course/"},{"title":"防抖 ( Debounce ) 和節流 ( Thorttle )","text":"會找到這篇文章的你，應該是在近期聽到了這兩個名詞對吧？我其實是在上週的面試過程中被問到了這個對當時的我來說非常陌生的兩個詞。一起來看什麼是 JS 的防抖和節流吧！ 名詞介紹開門見山的說，這兩種方法其實都是為了降低網頁在短時間內重複觸發 Function 太多次所造成的效能浪費，所以簡而言之他們的出現其實就是為了減少沒必要的監聽事件所觸發的次數。那下面就來一起看一下防抖和節流分別是怎麼處理這樣的需求的？ 防抖 Debounce什麼是防抖 Debounce ? 當我們所監聽的事件在固定的時間長度內再次被觸發時重新計算該時間長度，直到該時間長度結束時沒有再發生監聽的事件後才會確實執行該函式。 這樣講可能比較抽象，以生活化一點的例子來舉例的話就像是大賣場或是捷運裡面的電扶梯：當電扶梯的感應器偵測到有人踩上踏階時，它就會持續地運轉讓乘客移動到不同的樓層。但是當它的感應器一段時間（可能是 5 分鐘？我也不確定）都沒有偵測到任何人走到電扶梯的踏階上時，它就會觸發待機模式，並將電扶梯調整為較低的轉速。 所以這邊待機模式的觸發條件設定，就是利用防抖 Debounce 這個概念，否則如果每個乘客中間都一直觸發待機模式然後再重新啟動調整為正常速度的話，這樣對電扶梯也是一種耗損跟耗電的 實際應用範例 如果是以網頁常見功能來說明的話就是各大搜尋引擎的 Search Bar 了，在我們 key 入每一個關鍵字後，下方的搜尋引擎建議結果也是採用防抖的設計。 所以當你在頁面上快速鍵入許多單字觸發了 keyin 或是 keyup 事件時時，它不會馬上就去資料庫拿出搜尋建議的結果，它會等到你輸入完且沒有再偵測到新的鍵入 event 時才將相關的搜尋建議渲染在 Search bar 下方。 節流 Thorttle什麼是節流 Thorttle ? 監聽到事件發生且經過一段固定的時間長度後，就會觸發該函式。 我們可以假設固定的時間長度為 5 秒，因此只要在監聽事件成立後這 5 秒內即使再次監聽到新的事件也不會影響它每 5 秒要執行一次的結果。 用一個生活化一點的例子來跟大家（還有自己）說明的話，就像是打 LOL 的時候每個英雄的四個招式還有兩個召喚師技能都會有它的 CD 時間，所以你如果觸發過上述的招式或技能時，你必須要等待它固定的冷卻時間結束後才能重新使用該技能。 實際應用範例 節流最常見的應用就是在各大社群媒體平台上面了，當我們想要看更多內容而滑至頁面底部時，會偵測到使用者目前已經瀏覽完我們提供的內容，這時候依照設定好的新內容數量再透過 API 發送請求，將新的內容渲染到下方。 結論就像開頭所說的那樣，防抖跟節流都是為了減少監聽事件過於頻繁的觸發所做的一種設計方式。其實我們在平常的開發或是 Side project 中可能曾經都有使用過這樣的概念來撰寫我們的 function ，只是從來沒有想過它是基於這兩個關鍵字來達成的。 寫越久的 code 真的越發現自己在不知不覺中也會碰到很多城市設計原則相關的內容呢！那我們下次見ʘ‿ʘ 參考資料 從動圖輕鬆解題：防抖與節流 函數防抖(Debounce) 與 函數節流(Throttle) 面试官：什么是防抖和节流？有什么区别？如何实现？","link":"/2023/09/13/JavaScript-Debounce-and-Thorttle/"},{"title":"踩雷系列：%E2%80%8B 神奇的空白","text":"此篇文章同時收錄在我的 Medium 中，之後都會統一更新在 Hexo 這邊囉！ 事情是這樣發生的…上週和後端工程師開始進行專案的協作時，他提供了一份 Swagger UI 的文件讓我們做 API 的介接。一開始我就像撰寫其他專案一樣，將 Swagger UI 文件內所有的 API 統一複製貼上到 All.js 的檔案中，並在需要使用的頁面來介接。不過就在使用第一個 GET 的 API 時就出現 status 404 的狀況： 問題出在？ 通常出現 4 開頭的 status code 我就會確定是 client 端的問題，於是我就開始檢查我的 API URL 還有 axios 介接的方法有沒有寫錯？不過怎麼檢查程式碼和檢視 nuxt 的撰寫方式後都看不出來哪邊有問題和狀況？所以我就回頭看看 Console 視窗內的這個錯誤訊息，這才發現到一個很詭異的地方： 咦？ URL 中間怎麼多了幾個 %E2%80%8B 的字串？ 起初想說是不是 URL 自動將我的斜線編譯成 Unicode 了 ? 不過我又在 %E2%80%8B 後面看到了 / ，所以我就直接將 %E2%80%8B 這個字串丟到 Google 上去看了一下，究竟這是什麼鬼東西？ %E2%80%8B is the code for a “ZERO-WIDTH SPACE” character. 好！這下直接解開謎團了，原來是一個叫做 Zero-width space 的字元，中文翻譯也很直白，就叫做「零寬空格」。所以就如同字面上的意思，它是不會顯示出間隔的空格（怎麼有點饒口？） 使用 JS 的 decodeURI 將該編譯字元解碼後，可以看到解碼過後的空字串大家應該可以更加理解到什麼叫做「零寬空格」了吧？所以知道問題出在哪邊之後就開始著手更改這些因為懶得自己打的 API URL 而報錯的狀況了 解決方法如果專案內沒有太多的 API 那你可以先將複製貼上的 URL 移除後，再自行手動輸入即可（不要再偷懶ㄌ）。不過如果是像我一樣一次大量的複製貼上的你，那就只能用程式碼來解決了 1url = decodeURI(encodeURI(url).replace(/%E2%80%8B/g, '')) 記得在發送 Request 之前，將 URL 中的零寬空格使用空字串來取代。 後記後來在找解決方法的時候，確實在 Stack Overflow 上看到很多從 Swagger UI 文件上複製貼上 URL 的開發者也遇到相同的問題。也有蠻多人感嘆剛開始遇到這個問題真的百思不得其解？還跟後端對了好多次，透過 POSTMAN 等工具確認 API 介接都是正常無誤的，最後發現是這個問題的時候簡直傻眼的人也是不少。不過很幸運自己是在和後端求救之前有先找到問題點在哪的？ 開發的日子久了，什麼奇怪的 Bug 都能遇到呢 這系列果然算是蠻快就更新了希望大家很不幸遇到這個坑的時候可以馬上找到我這篇文章！那我們下次再見ʘ‿ʘ 參考資料菜雞抓蟲: Url 變得怪怪的？你可能是零寬空格（ZWSP）的受害者！ - 伊果的沒人看筆記本","link":"/2022/11/28/blank-space-debug/"},{"title":"16 進位 ( Hexadecimal Number System )","text":"今天要來紀錄一下在撰寫 API 的時候第一次聽到的名詞： 十六進制 Hexadecimal 什麼是十六進制（ Hexadecimal ）？ 十六進制（ Hexadecimal ），也叫十六進位或者簡稱為 Hex ，是一種數字系統。這個數字系統總共使用了 16 個符號來表示數字，分別為：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F 等 16 個符號。 在十六進制中，每個位數的值就是 16 的次方，而每個位數都可以使用上面所列出的 16 個符號來表示。 從 A 開始代表的值為 10 ， B 為 11 ，以此類推 F 則為 15。 範例介紹假設在十進制的數字 15 ，它就會等同於十六進制中的 F 符號（ F 代表的值是 15 ）。若是在十進制中的數字 16，換成十六進制的數字時則為 10 。 為什麼是 10 ?因為在十六進制中，數字 10 中的 1 代表的是 16 的 1 次方，再加上了右邊的 0 代表的是 16 的 0 次方，兩者相加就為 16 ，這就是十進位中的數值了。 應用場景為什麼會在開 API 的時候遇到這個名詞呢？最主要的原因就是當初在設定回傳的 response 中會使用到十六進制的計算方式來計算我們的 API 中所回傳的資料長度，因此才知道了這個名詞。後來才知道在計算機概論和數字系統中，很常使用十六進制來表示二進制的數字。因為每個十六進制的數字可以表示出更多單位的二進制數字，所以才應用在這個領域當中。 那我們下次見ʘ‿ʘ","link":"/2023/03/06/hexadecimal-hexi/"},{"title":"踩雷系列：ICARUS 的樣式設定檔案在哪裡？","text":"在 Hexo 技術部落格建好之後，開始想要微調一些樣式設定（蠻喜歡 Medium 那種簡約的風格），所以開始搜尋要怎麼修改我使用的樣式 ICARUS ，下面就來跟大家分享一下設定的內容： ICARUS 的樣式設定檔案位置樣式的檔案是在 node_modules 的資料夾內，資料夾的路徑是 hexo-theme-icarus/include/style這邊會建議大家新增一個自己的樣式檔案並在裡面填寫你修改的內容，當然也可以直接修改原始的 ICARUS 的樣式檔案。 為什麼這篇是放在踩雷系列？沒錯！應該有人會困惑說這篇看起來沒有任何的雷啊？但是我在修改樣式的初期一直找不到 ICARUS 的樣式檔案在哪邊？甚至還跑去修改編譯過後的 CSS 檔案，所以理所當然的，樣式是不可能有調整。因此我確實花了一段時間找到了原來樣式設定的檔案們在哪邊？確實有點搞笑 XD希望有使用 Hexo 搭配 ICARUS 的大大們都不要像我一樣找超久 QQ 修改的內容這邊有參考了其他網站的設定教學，調整了旁邊的 sidebar 和文章區塊的比例，因為教學文章很詳細，所以會附在下方的參考資料給大家！ 那我們下次見ʘ‿ʘ 參考資料Hexo - Icarus 主題 - 內容區塊寬度","link":"/2023/02/08/icarus-style-file/"},{"title":"Kata Practice C# - DNA to RNA Conversion","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Deoxyribonucleic acid, DNA is the primary information storage molecule in biological systems. It is composed of four nucleic acid bases Guanine (‘G’), Cytosine (‘C’), Adenine (‘A’), and Thymine (‘T’). Ribonucleic acid, RNA, is the primary messenger molecule in cells. RNA differs slightly from DNA its chemical structure and contains no Thymine. In RNA Thymine is replaced by another nucleic acid Uracil (‘U’). Create a function which translates a given DNA string into RNA. For example: “GCAT” =&gt; “GCAU”The input string can be of arbitrary length - in particular, it may be empty. All input is guaranteed to be valid, i.e. each input string will only ever consist of ‘G’, ‘C’, ‘A’ and/or ‘T’. 自己的解法123456789namespace Converter { public class Converter { public string dnaToRna(string dna) { return dna.Replace('T','U'); } }} 解題脈絡按照問題的敘述先去 Google 找 C# 有沒有相對應的方法？於是就找到了 Replace 的這個方法，不過感覺這樣只是解決了基本的需求。當然這樣還是有符合題目的需求，但感覺應該還有更符合日常開發的狀況，所以就看了其他人的 Solution。 其他人的解法1234567891011121314namespace Converter { public class Converter { public string dnaToRna(string dna) { char[] dnaLetters = new char[4]{'G','C','A','T'}; string upperCaseDna = dna.ToUpper(); if(upperCaseDna.Any( letter =&gt; !dnaLetters.Contains(letter))) throw new ArgumentException(); return upperCaseDna.Replace('T','U'); } }} 選擇這個解法的原因雖然直接使用 Replace 可以完成需求，不過參考的這個 Solution 有將每一步的邏輯都整理起來，即便相較原本的寫法多了一些變數和判斷，但是這樣確有助於釐清整個程式碼的可讀性。即便不需要註解也可以知道這個 Class 在解決的問題是什麼？ 觀念釐清希望之後自己在練習 kata 的時候也能夠想到比較全面的練習，不僅僅是只符合題目的需求而已。 那我們下次見ʘ‿ʘ","link":"/2023/05/18/kata-dna-to-rna-conversion/"},{"title":"終於建好了！我的 Hexo 技術部落格","text":"這是我的技術部落格的第一篇文章！實在是太感人了！講了好久的部落格一直都停留在想法的階段，但卻沒有真的去執行，直到前幾天發現了好多前端的前輩們都使用這個 Hexo 的套件快速建立網站後就決定著手開始了。 為什麼會想要建立技術部落格？其實最一開始我都是使用自己的 Notion 來做前端技術的筆記撰寫並建立起自己的技術資料庫，當初確實也有想過是否要將自己的筆記公開來，但是心中卻產生了一種如果我寫的是錯的怎麼辦？如果我誤人子弟怎麼辦？不過最後是在洧杰的一句話裡直接茅塞頓開： 想太多了吧！根本就不會有人看你的文章啦～ 所以就決定開始在自己的 Medium 發表一些技術文章和筆記，試著將自己學習的技術內容做紀錄，但也陸續發現關於 Medium 這個平台的一些狀況還有我個人的心理因素（又來！ Medium在 Medium 寫了幾篇文章後，確實有被一些人看到和獲得了拍手鼓勵，所以一開始是還蠻有成就感的。但是我漸漸發現該平台比較多英語使用者，加上大部分中文的文章也都屬於品質比較好的技術內容。 於是我漸漸發現，像是自己寫的這種筆記類型的文章好像不那麼適合在這個平台發布，所以就開始想說要自己建立一個技術部落格了。 自己架設部落格有了想要自己架設部落格的想法之後，就開始萌生出了許多要考量的點，像是： 網站的 UI 要設計成什麼樣子？ 需要有什麼功能方便使用者瀏覽文章？ 文章寫好之後要用什麼資料格式存放？ 整個部落格應該要放在哪個伺服器服務？ 想了一想，覺得這麼多東西要安排和規劃，那之後再說吧～ 對！就是這句之後再說吧的話就讓這個部落格計畫完全停滯不前，因為光想到上面列的那幾個問題就提不起勁要開工了 QQ 所幸在前幾天意外看到了 Ray 的鐵人賽文章 試著學 Hexo 後，才終於下定決心要來試著架設自己的技術部落格了。 Hexo於是照著鐵人賽文章裡面的內容開始安裝了 Hexo 並且逐步的將自己的部落格建立了起來，也意外發現其實蠻多前輩都是使用這個服務在撰寫自己的技術文章的。而且有了技術部落格之後內心突然覺得很踏實，終於有一個可以讓自己放心紀錄的平台了！ 關於部落格之後的走向？有大概想了一下這個部落格要發表的內容，不過其實不太想全部都侷限於技術的東西，有時候一直追技術也是頗累的XD所以之後應該會按照著這幾個大項目來做技術和其他日常的文章撰寫： 預計有的 Categories 技術文章系列：舉凡任何的框架、工具或程式語言的專門技術文章 踩雷系列：紀錄自己開發過程中遇到的 Bug 並祈禱不要太多人剛好需要這篇文章 SuoChan：紀錄身為前端工程師的日常或是一些心路歷程 目前想到的大項就是這三點了，或許之後會再新增也不一定？ 期許簡而言之，希望建立好這個部落格之後自己能慢慢的重回到渴望學習新技術和工具的狀態。 然後這篇文章沒有要教大家怎麼架設自己 Hexo 部落格喔！之後確實會透過文章紀錄我是怎麼從無到有建立的，但如果已經等不及的話可以先參考上面 Ray 的鐵人賽文章。那我們下次見ʘ‿ʘ 參考資料 試著學 Hexo 系列 Markdown 教學","link":"/2022/11/05/personasl-hexo-blog/"},{"title":"React.js 學習記錄：什麼是 React.js ?","text":"此篇文章同時收錄在我的 鐵人賽文章 - React.js 30 天學習全記錄 中，之後會同步更新在 Hexo 這邊唷！ 我自己在學習新技術的時候比較習慣先暸解一下這個技術的基本概念還有它解決了什麼問題。所以今天我要跟大家一起來看 React.js 到底是什麼？它又能夠幫我們做什麼呢？ 什麼是 React.js ? A JavaScript library for building user interfaces. 沒錯！從官網進去後，印入眼簾的就是這段話。所以 React.js 其實就是一個用來打造 UI 的 JavaScript 函式庫，而且它是由 Facebook 團隊所開發出來的。在 Facebook Open Source 中不只有 React.js 而已，現今撰寫 APP 常用到的框架 React Native 也是由他們所開發的（在 Facebook Open Source 的網站中可以瀏覽其他由該團隊開發的框架和函式庫）。 框架 Framework？ 函式庫 Library？隨著網頁開發的功能越來越多元、內容也越來越複雜後，工程師們為了解決開發上衍生出的種種問題而寫出解決這些狀況的框架和函式庫。不過看了那麼多資料跟介紹不斷地提及框架和函式庫，我真的每次都被搞得頭昏眼花。結果就在搜集資料和瀏覽文章的時候看到了這篇文章仔細地分析了究竟這兩者的差別在哪？ 差異在於，使用「框架」的話，框架具有控制權，而身為這份軟體的開發者，你需要依照框架的設計把功能填上，填完的之後，程式便會照你的意思運作了；「函式庫」則是不同的，它像是一個彈藥庫，裡面藏有各種武器供你使用，你有控制權去決定怎麼使用它們，甚至不使用。 看完這段敘述之後我們大概可以了解這兩者之間的差異了吧？想想看以前在練習 Side Project 的時候如果遇到不會的功能，可能會去 CodePen 上面找看看別人的範例。而這些範例當中會有些人在特定的地方使用到 jQuery 這個 函式庫 (library) 但是並不一定所有的內容都會使用到（可能一部分是寫原生的 JavaScript ）。不過當你是使用 Vue.js 這個 框架 (Framework) 的時候，就是必須按照它設定好的環境來撰寫特定的語法來開發整個功能。 所以你有發現一件事情嗎？在你見過的大多數資料內所提及目前的前端三大框架 Angular 、 Vue.js 以及 React.js 中， 其實有一個根本就不是框架而是函式庫，它就是 React.js ！ React.js 可以解決什麼問題？透過上面的內容我們現在對 React.js 可以說是有初步的認識了，但是所有的工具（不管是框架或函式庫）被開發出來都是為了要解決問題，讓我們能夠更便利更快速地進行前端開發。講了這麼多，所以 React.js 到底提供了哪些功能來幫助我們呢？ 要了解它能幫你解決什麼問題前，你其實應該先問問自己一個問題：在最一開始學習 JavaScript 做前端開發時遇到了哪些狀況？ 這邊先列幾個我曾經寫原生 JavaScript 寫到懷疑人生的時候遇到的狀況給大家作為參考： 設定很多 DOM ，光想命名就崩潰。之後除了要監聽事件，還要注意綁定的 DOM 是否正確？否則也監聽不到。 不斷地在渲染(Render)畫面。如果要渲染的區塊比較多資料的話，程式碼就會看起來又臭又長。 有些功能類似的開發，因為資料還是有些微的不一樣就一直重複撰寫相似的內容。 以上就是我目前想到當初在使用原生 JavaScript 開發的時候遇到的難處和困擾。當然我相信這不會是只有我一個人遇到的狀況，所以這些開發困境也是讓後來許許多多的 JavaScript 框架和函式庫不斷出現的原因。 所以知道自己的問題在哪之後，我們就來看看 React.js 這個函式庫究竟提供了什麼樣的方法來幫助我們脫離上面的種種困境呢？ React.js 的兩大特色 宣告式 Declarative 在 React.js 中的 View 是採用宣告的方式並使用 Virtual DOM 的概念來進行綁定和渲染。它會在資料有變更時更有效率的自動更新並渲染 （Render） 所有有產生變動的元件。簡單來說，這代表當我的資料或內容有更新的時候，我不再需要去重新渲染出整個區塊的資料，而是透過宣告式的 View 來直接幫我更新畫面上那些有變更的資料而且需要重新渲染的部分即可。 所以這部分就解決了我們前面提到不斷的再重新渲染頁面的問題了。 元件式開發 Component-Based React.js 是以 元件為基礎 來做開發的，因此你可以自行定義不同的元件並設定每個元件不同的狀態（state），以及透過傳送給子元件（props）的方式來進行資料的傳遞。而基於這樣的元件基礎開發模式之下，我們就可以將網站中會重複利用的東西（像是按鈕等）定義成一個元件，並針對不同用途或功能去做設定資料（像是按鈕上面的文字）。 所以這部分則是解決了原生 JavaScript 在開發上會重複撰寫相同功能但是不同資料的東西，大大的簡化程式碼之外也提升了可閱讀性和之後要修改的便利性。 以上都是 React.js 為我們提供的強大功能，不過還有很多等著我們探索的地方，所以就繼續讀下去吧！另外有任何問題都非常非常歡迎提出和指教唷～那我們下篇見ʘ‿ʘ","link":"/2023/01/22/reactjs-learning-whats-framework-library/"},{"title":"Kata Practice C# - Opposites Attract","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Timmy &amp; Sarah think they are in love, but around where they live, they will only know once they pick a flower each. If one of the flowers has an even number of petals and the other has an odd number of petals it means they are in love. Write a function that will take the number of petals of each flower and return true if they are in love and false if they aren’t. 123456789using System;public class LoveDetector{ public static bool lovefunc(int flower1, int flower2) { //Moment of truth... }} 自己的解法123456789101112131415using System;public class LoveDetector{ public static bool lovefunc(int flower1, int flower2) { if( flower1 % 2 == 0 &amp;&amp; flower2 % 2 == 0 ){ return false; } else if ( flower1 % 2 != 0 &amp;&amp; flower2 % 2 != 0){ return false; } return true; }} 解題脈絡一開始就是照著題目的 Description 來寫，所以其實程式碼很直觀，但換個說法就是爛到不行哈哈！不過我覺得對於自己目前的程度來說就是盡量地用自己現有的思維去寫，然後再透過大家的 Solution 來學習別人寫程式的邏輯。可以備註的地方應該是在解題時我就有知道這樣的解法不是最佳解，這樣就是把所有的條件都各別列出來而已。 其他人的解法123456789using System;public class LoveDetector { public static bool lovefunc(int flower1, int flower2) { return (flower1 + flower2) % 2 == 1; } } 選擇這個解法的原因這邊的話會盡量選擇自己看得懂而且能夠理解的寫法來做紀錄，其實同樣的練習可能還有你認為更好的做法，那這部分你可以透過自己解題 Submit 後再去參考其他人的。會選擇這個解法的原因是 flower1 + flower2 如果被 2 取餘數是 1 的話就代表這兩個參數有一個不是雙數了，因此兩個雙數相加後取餘數就會等於 0 並符合題目要求的返回 False 的值。 觀念釐清後來發現是自己沒有搞清楚 % 這個算術運算子的功能其實是取餘數，所以才繞了一大圈把所有的條件都寫出來，雖然有點丟臉但不過現在也因此加深印象了 XD 那我們下次見ʘ‿ʘ","link":"/2023/05/13/kata-opposites-attract/"},{"title":"33355 ? Scrum 中的第一個 3 - 三個角色","text":"這一篇要來跟大家分享的是基於 Agile 敏捷開發的 Scrum 框架中的 3 個角色有哪些？如果對於 Scrum 這個概念有點不是很了解的地方，之後會再另外整理一篇文章跟大家說明，這篇會著重在介紹究竟有哪些角色？他們分別又負責了哪些工作內容？讓我們繼續看下去 … Scrum 中的三個角色在執行 Scrum 的團隊當中，會有三個不同的角色執行不同的任務與職責來確保團隊的開發能夠順利地按照規劃來執行。那下面我們就來看一下這三個角色分別為何？ Product Owner 產品負責人通常在團隊中也會簡稱為英文單字的縮寫 PO ，下面就用 PO 代稱產品負責人。 PO 最主要的職責就是作為客戶與團隊之間的橋樑，需要瞭解客戶目前的需求以及期望獲得解決的方案等等，因此 PO 在釐清客戶需求的同時也必須確保開發團隊能夠確實知道客戶需要的功能或是服務是什麼？ 並且將每個需求的優先順序排列出來，讓開發團隊知道每個任務的優先順序是什麼以及為什麼？ PO 這個角色在我還沒有加入有導入 Scrum 的團隊時，我一直覺得這個職位和 PM 是相同的。不過在加入我們公司的 Scrum 團隊後發現 PO 對於客戶的需求必須有更進一步的理解，因為他必須能夠幫客戶判斷這個功能的優先程度是什麼？這樣開發團隊才能依照輕重緩急和順序來做開發，完成需要交付給客人的產品。 Development Team 開發團隊 在 Scrum 當中的開發團隊不只有軟體工程師，舉凡所有會跟開發工作相關的跨職能職位都會包含在這個團隊中，像是 UI 或是測試等項目都包含在其中。其職責最主要就是要順利完成每一次 Sprint 所設定目標 ( Sprint Goal )，並互相幫忙和提出意見以確保團隊都能一起解決定好的目標和問題。 在 Scrum 中的開發團隊會以 Team 的目標為首要任務，在這樣的團隊裡面不需要互相競爭比較，而是會將目光放到團隊要解決的問題上，變成一個以團隊為核心的概念。 Scrum Master唯一一個沒有翻譯成中文的角色，通常在團隊內都會直接稱做 Scrum Master 或是簡稱 SM ，下面就統一使用 SM 稱呼。 SM 就像是執行 Scrum 的教練，他會參與整個團隊的會議並且確保 Scrum 能夠順利的在團隊內執行，同時也會在過程當中給予一些會議流程或是方法上的改善與建議。 這邊要特別注意的是，雖然 SM 在團隊當中應該算是最透徹了解 Scrum 框架該怎麼執行的一個職位，不過在團隊中他僅能夠作為一個就他所觀察到的一些問題或是能夠優化的流程提出他專業意見的人，而要不要採納 SM 的建議以及解決方案則是決定在開發團隊本身，他並沒有權利叫團隊該如何進行會議或開發。 在公司內部有發現許多不同背景的人轉職成為 SM ，而不同背景出身的 SM 也會帶來許多不同的火花。像是我們團隊的 SM 就是從工程師背景轉過來的，因此他在提出一些想法和意見的時候就能夠用更貼近開發團隊的思維來提供，這點我個人覺得是一個蠻不錯的優勢。 SM 的職責還有這個職位實際上要點的技能樹有哪些？我還沒有完全的了解，之後再找時間把這塊知識給補上（或是請教 ChatGPT 好朋友） 結語接下來還會有四篇的文章來說明這個 Scrum 框架的口訣 33355 後面的四個數字分別代表什麼？有寫錯或是語意不通順還是不理解的部分歡迎大家踴躍留言，也感謝讀到這邊的各位大大，希望有為你們解惑唷！那我們下次見ʘ‿ʘ 參考資料 [DAY 09]角色設定01:Scrum三角色 一些產品負責人的怪味道 – 談Scrum Product Owner常見的誤區","link":"/2023/02/16/scrum-framework-three-roles/"},{"title":"Vue.js : v-on 事件綁定指令","text":"v-on 是一個 Vue.js 的事件指令，是用來綁定在 DOM 上做為事件監聽和執行指定函式的功能。 v-on 的實作v-on 的寫法為 v-on:事件名稱=”執行的函式” ，其實這就等同於我們使用 JavaScript 所撰寫的 querySelector 以及 addEventListener 這兩個功能。 JavaScript 寫法12// HTML&lt;button class=&quot;btn-add&quot; /&gt; 123// JavaScriptconst addButton = document.querySelector('.btn-add');addButton.addEventListener('click', count++) 先在 HTML 建立 class 或是 id 名稱（建議使用 class 名稱），並在 JavaScript 的檔案中綁定指定的 DOM 的 class 或是 id 名稱後再使用 addEventListener 來監聽指定的 click 事件，並執行 count++ 這個函式。 v-on 寫法1234&lt;template&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;button class=&quot;btn-add&quot; v-on:click=&quot;count++&quot; /&gt;&lt;/template&gt; 直接在要綁定監聽事件的 DOM 上使用 v-on 的指令之後，加上要監聽的事件名稱和要執行的函式即可。 v-on 的簡寫實務上不大會使用 v-on:事件名稱=”執行的函式” 這樣的寫法，比較常使用的是 @事件名稱=”執行的函式” （貫徹工程師能省則省的簡單寫法）。 1234&lt;template&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;button class=&quot;btn-add&quot; @click=&quot;count++&quot; /&gt;&lt;/template&gt; 那我們下次見ʘ‿ʘ","link":"/2023/01/04/vuejs-von-directive/"},{"title":"C# Challenge 02 - 在 C# 中使用常值與變數值來儲存及擷取資料","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第二單元章節的內容。 本節內容C# 型別 char：單一字元，在使用和宣告時是採用單引號的方式。 string：字串，在使用和宣告時是採用雙引號的方式。 int：整數，在使用和宣告時不需要採用特殊的方式，直接輸入數字即可。 浮點數：根據小數點的數目，再細分為三種類別 float: ~6-9 digits double: ~15-17 digits decimal: 28-29 digits，記得在數字的最後加上 m 或 M。 bool：布林值。 變數的命名規則 變數名稱可包含英數字元與底線字元。 不能使用井字號 # 或貨幣符號 $ 之類的特殊字元。 變數名稱的開頭必須是字母或底線，而不是數字。 變數名稱會區分大小寫，這表示 string Value; 與 string value; 是兩個不同的變數。 變數名稱不得為 C# 關鍵字。 例如：decimal decimal; 或 string string;。 var 關鍵字使用使用 var 關鍵字來宣告變數時，請務必初始化該變數的值，否則會看到 output 中的錯誤訊息。 重點整理主要注重在變數的資料型別以及該如何宣告，個人覺得 C# 的資料型別上在小數點跟字串的部分都更加的詳細，可能要花點時間適應。畢竟寫了太久的弱型別 JavaScript 實在不太習慣在宣告變數時就要加上型別的操作，但相信這絕對是個好的開發形貫的養成的！那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/2023/09/22/C-02-Challenge/"},{"title":"GraphQL 是什麼？ GraphQL &amp; RESTful API 的差異","text":"近幾個月求職的時候越來越常在 JD 和面試的時候被問到關於 GraphQL 的相關概念，所以就決定開始來研究 GraphQL 究竟是什麼？它能應用到的場景是哪些？一起來一探究竟囉！ 什麼是 GraphQL ? A query language for your API. 進入官網斗大的標題就直接明瞭的告訴你了，不過我必須承認我在研究這個主題時看到這句話其實是滿頭問號的。原因很簡單，因為我不知道為什麼需要查詢我的 API ，所以在解釋 GraphQL 前，我們應該要先來了解一下 GraphQL 是為了解決什麼問題而誕生的？ 還沒有 GraphQL 的時代 在 GraphQL 出現之前，API 設計通常會選擇使用 RESTful 的設計風格，這種風格的 API 具有固定的端點結構且每個端點代表一個資源，並且使用 HTTP 方法（ GET / POST / PUT / DELETE 等 methods ）執行操作。這種方式有其優勢，但也存在一些限制，特別是當客戶端需要不同組合的數據或自定義查詢時。 這邊的端點指的就是 API 中固定的 URL 結構，像是： 獲取所有用戶：/api/users 獲取單個用戶：/api/users/{userId} GraphQL 解決的問題 所以 GraphQL 的核心功能之一：讓用戶可以根據自身的需求自定義要查詢的項目，而不需要像 RESTful API 遵循固定的端點結構，讓其他不相關的資料也一併回傳。 看一下下面的 GraphQL 的 request 範例： 123456789101112POST /graphqlContent-Type: application/json{ &quot;query&quot;: &quot;{ user(id: 1) { id name email } }&quot;} 可以發現我們的 API 端點 url 統一為 /graphql ，而在 request 中我們可以直接指定我們只要 id 為 1 的使用者資料，其他的使用者資料都不需要回傳過來。 這邊可能有人會好奇說，這樣不是跟 RESTful API 一樣嗎？只是我在 url 上面要多帶一個 id 的參數就好。 不過這也直接點出了 RESTful API 的劣勢，你必須根據請求端需要的資料來做設計不同的端點，但是 GraphQL 在端點的部分都統一，讓我們直接從 client 端去選擇自己要收到的 response 是什麼？ 所以 GraphQL 到底是？ GraphQL 不只是一種查詢 API 的語言，它也是用於建立靈活、高效、精確數據API的工具，同時還是一個執行引擎，用來負責解析和執行這些查詢。 希望透過上面的說明大家可以更知道 GraphQL 在做什麼？ 因為我之前很常把它跟 RESTful API 搞混，所以才特別把這些我當初困惑的問題都整理出來。 GraphQL 和 RESTful API 的差異 差異 GraphQL RESTful API API 端點 用戶可以通過一個單一的端點發出具體的查詢來擷取所需的數據，而不需要多個不同的端點。 使用多個不同的端點（資源路徑）來執行特定操作。每個端點通常代表一個特定的資源和操作（GET、POST、PUT、DELETE等）。 過度請求 使用查詢語言使得過度請求的狀況出現時相較容易控制，因為 client side 可以精確的指定所需要的資料即可。 如果遇到過度請求問題通常需要通過創建不同的端點或自定義參數來解決。 版本管理 通常不需要版本管理，因為 client side 可以根據需求撰寫新的 query。 比較需要版本管理，以確保現有的 client side 能正確取得 response，且當 API 發生新的需求必須變更時，通常就要創一個新版本的端點。 結語直接引用 ChatGPT 幫我做的結論 GraphQL 是一個用於設計和實現API的工具，它的核心是 查詢語言和執行引擎 ，讓客戶端能夠根據其需求自定義查詢。而 RESTful API 則是一種特定的 API 設計風格，它遵循 REST 原則，使用 HTTP 方法來執行操作。這兩者在設計和使用上有很大不同，可以根據項目的需求選擇適當的工具和風格。 總算搞懂了這個工具到底在做些什麼？雖然目前都還沒在工作上接觸到，不過對 GraphQL 的印象確實很不錯，希望之後有機會可以實際使用到。那我們下次見ʘ‿ʘ 參考資料 GraphQL 什麼是 GraphQL？ 為什麼要學 GraphQL? GraphQL 和 REST 有何區別？ GraphQL是什麼？給新手的入門教學指南","link":"/2023/09/22/graphql-restful-api-design/"},{"title":"NPM 更新後所有指令都失效了？ NPM 和 Node.js 版本號支援問題","text":"踩雷系列全部的題材保證都是本人親自踩過的，希望各位如果剛好不幸遇到的話也能夠幸運的找到我的這篇文章幫你解惑！ 事件經過又是一個平凡的開發日常，打開自己電腦內的 iTerm 時看到了一個 npm 的更新通知，索性就輸入 npm install -g npm 來安裝更新檔。結果更新完後要使用 npm run dev 執行自己的 Vue3 專案時看到了以下的畫面： 一個錯誤訊息跳了出來 1Error: Cannot find module 'timers/promises' 這時候我嘗試去執行其他的專案也通通遇到一樣的錯誤訊息，於是就開始 google 和 Stack Overflow 來尋找答案的旅程了。 踩到的雷最後在這篇文章 Error: Cannot find module ‘timers/promises‘ 找到了踩到的雷是什麼？原來是因為升級後的 npm 沒辦法支援現在本地端 node 的版本，所以版本相互不支援的情況間接導致我沒辦法順利執行所有 npm 相關的指令。 解決方法於是我就去查了一下目前可以支援這個 npm 版本的 node 版本有哪些？ 並指用 nvm 這個 node 版本管理工具將當前的 node 版本更新為有支援的 node 18 後就順利解決了。 後記後來發現，其實在我一開始升級完 npm 之後， iTerm 就有顯示 Warning 的訊息告訴我，更新後的 npm 和我本地端目前的 node 版本是不支援的，必須同步將 node 一起升級才可以。所以看到這邊你可能會想說，究竟是我踩到了雷還是我自己就是那個雷呢？Who knows? 哈哈哈哈哈 那我們下次見ʘ‿ʘ 參考資料Cannot find module ‘timers/promises’","link":"/2023/09/23/npm-node-version-error-problem-solution/"},{"title":"VSCode extension 遇到 Jumpy 和 Vim 的衝突事件","text":"踩雷系列全部的題材保證都是本人親自踩過的，希望各位如果剛好不幸遇到的話也能夠幸運的找到我的這篇文章幫你解惑！ 事件經過最近在著手練習 React + TypeScript 的內容時，看到了技術文章內有推薦適合這個框架組合的開發者一些 VS Code 的套件，這時候看到了之前在 Rider 這個 IDE 中有使用過的 AceJump 套件，能夠讓你快速地跳到指定字元的位置做編輯或撰寫程式碼。在 VS Code 中的套件名稱為 Jumpy ，了解了該如何使用後就下載安裝了起來。結果要開始使用的時候就發現，當提示的反光字元出現時，我沒辦法輸入字元去跳至對應的位置。所以就開始 Debug 了。 踩到的雷最後在 Jumpy 的 GitHub Page 中的 Issues 看到了這個討論，發現如果你有在 VS Code 中安裝 VSCodeVim 這個套件的話，你無法順利的執行 Jumpy ，因為他會在你輸入指定字元的時候觸發到 Vim 的指定。 解決方法 後來在上面所提及的討論串當中發現有一位作者直接將原本的 Jumpy 重新開發一個新的 Jumpy2 ，讓 VSCodeVim 的使用者可以同時使用這兩個套件不衝突，真是暴力又直接的解決方式ㄚ 後記這次的踩雷讓我發現，開發日子在久了之後真的就是一直不斷的在面對這種版本衝突和不支援的狀況中度過。希望之後的開發遇到這種問題時不要卡關太久，都能順利解決！ 那我們下次見ʘ‿ʘ 參考資料 Jumpy Jumpy GitHub Page Jumpy2","link":"/2023/09/23/vscode-extension-vim-jumpy-solution/"},{"title":"Program and Process 程式與進程？ Thread 線程又是什麼？","text":"今天在找別人分享前端職涯發展的相關文章時，看到了一個關於非本科的有趣討論串，意外的看到了這幾個專有名詞。有趣的地方在於，正如發文者所說的，轉職仔大部分都不知道這些 Computer Science 的根本概念，而我正好就是其中那一位！所以今天想要來好好了解這些重要的 CS 基礎，不要淪為無情的寫扣機器 XD 那我們下次見ʘ‿ʘ 參考資料","link":"/2023/10/03/program-process-thread-cs-basic-knowledge/"},{"title":"終於等到了！CSS 新 viewport 單位 svh &#x2F; lvh &#x2F; dvh","text":"原本在我的 medium 預定排程中要撰寫的一篇文章就是我自己製作 side project 時遇到 Safari 100vh 的神奇之處，想不到還沒有等到我懶癌康復的那天到來，CSS 就直接推出新的 viewport 單位讓大家以後一勞永逸了。廢話太多，趕快一起來看新單位有多香吧！ 那我們下次見ʘ‿ʘ 參考資料","link":"/2023/10/04/css-new-viewport-units-svh-lvh-dvh/"},{"title":"C# Challenge 03 - 在 C# 中執行基本字串格式設定","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第三單元章節的內容。 本節內容逸出 Escape 字元 要在字串資料中使用雙引號的話，使用 \\ 跳脫。12Console.WriteLine(&quot;Hello \\&quot;World\\&quot;!&quot;);// output: Hello &quot;World&quot;! 如果字串內已經含有 \\ 的話，使用兩個 \\ 跳脫。12Console.WriteLine(&quot;c:\\\\source\\\\repos&quot;);// output: c:\\source\\repos 使用 @ 指示詞建立逐字字串常值，並保留字串中的所有空白字元格式設定和反斜線字元。 1234Console.WriteLine(@&quot; c:\\source\\repos (this is where your code goes)&quot;);// output: c:\\source\\repos // (this is where your code goes) 使用 \\u 加上四字元代碼來代表字串中的 Unicode 字元 (UTF-16)。要注意：根據不同的系統或是設定有可能沒辦法正確顯示出來。 12Console.WriteLine(&quot;\\u3053\\u3093\\u306B\\u3061\\u306F World!&quot;);// output: こんにちは World! 字串結合變數 1234string firstName = &quot;Bob&quot;;string message = &quot;Hello &quot; + firstName;Console.WriteLine(message);// output: Hello Bob 字串組合簡寫 1234// 原始寫法string message = greeting + &quot; &quot; + firstName + &quot;!&quot;;// 精簡寫法string message = $&quot;{greeting} {firstName}!&quot;; 透過 $ 搭配雙引號來完成字串的組合，會更方便也更直觀一點，而且也有點類似 JavaScript 的樣板字面值。 重點整理今天重點都是放在字串跟變數的處理，我覺得最後的挑戰和知識檢定很棒，因為你可以檢視自己有沒有好好吸收這些內容。但最值得讚賞的部分是我覺得它這個 Challenge 的每個章節都不會太長，所以你可以有耐心地完成每一個課程，這真的很重要我覺得（大幅影響學習意願 XD ）。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/2023/10/02/csharp-freecodecamp-challenge-03/"},{"title":"C# Challenge 04 - 針對 C# 中的數字執行基本作業","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第四單元章節的內容。 本節內容不同型別資料組合 1234string firstName = &quot;Bob&quot;;int widgetsSold = 7;Console.WriteLine(firstName + &quot; sold &quot; + widgetsSold + 7 + &quot; widgets.&quot;);// output: Bob sold 77 widgets. 編譯器會直接將所有 Console.WriteLine() 的內容視為字串，然後把它們全部串聯在一起。 但如果要將該字元視為數字進行運算時，可以使用 () 來表明這裡的值是要作為 int 來計算而不是 string 。 1234string firstName = &quot;Bob&quot;;int widgetsSold = 7;Console.WriteLine(firstName + &quot; sold &quot; + (widgetsSold + 7) + &quot; widgets.&quot;);// output: Bob sold 14 widgets. 基本運算子數學運算子 + 是加法運算子 - 是減法運算子 * 是乘法運算子 / 是除法運算子 小數點運算規則和型別 123decimal decimalQuotient = 7.0m / 5;Console.WriteLine($&quot;Decimal quotient: {decimalQuotient}&quot;);// output: Decimal quotient: 1.4 如果是小數點的資料要使用運算子的話，記得被除數或者是除數其中一個必須要是 decimal 的 type （或是兩者同時都是 decimal 也可以） 。 轉換型別後計算 但如果原本是 int 的資料型別卻想要做 decimal 小數點形式的資料轉換和計算的話，可以使用 (decimal) 來完成。 12345int first = 7;int second = 5;decimal quotient = (decimal)first / (decimal)second;Console.WriteLine(quotient);// output: 1.4 取餘數運算子 就是 % ，功能是計算資料後的餘數，如下面範例所示： 1234Console.WriteLine($&quot;Modulus of 200 / 5 : {200 % 5}&quot;);Console.WriteLine($&quot;Modulus of 7 / 5 : {7 % 5}&quot;);// output: Modulus of 200 / 5 : 0// output: Modulus of 7 / 5 : 2 運算子優先順序 Parentheses (括弧) : 必須先執行括弧內的內容 Exponents (指數) Multiplication (乘法) 與 Division (除法) : 由左至右 Addition (加法) 與 Subtraction (減法) : 由左至右 複合指派運算子 += 運算子會新增運算子右邊的值，並將其指派給運算子左邊的值。 int value = 0; // value is now 0. value = value + 5; // value is now 5. value += 5; // value is now 10. ++ 運算子會將變數的值遞增 1。 int value = 0; // value is now 0. value = value + 1; // value is now 1. value++; // value is now 2. 先遞增後遞增的範例這邊可以特別注意一下先遞增和後遞增的差異，附上 ChatGPT 的說明在下方。 int value = 1; value++; Console.WriteLine(&quot;First: &quot; + value); Console.WriteLine($&quot;Second: {value++}&quot;); Console.WriteLine(&quot;Third: &quot; + value); Console.WriteLine(&quot;Fourth: &quot; + (++value)); // output: First: 2 // Second: 2 // Third: 3 // Fourth: 4 先遞增(++value) ： 在進行遞增操作之前，首先會將變數的值加 1，然後返回遞增後的值。換句話說，先遞增操作會首先增加變數的值，然後返回新的值。 後遞增(value++) ： 在進行遞增操作之前，首先會返回變數的當前值，然後再將變數的值加 1。換句話說，後遞增操作會首先返回當前的值，然後再增加變數的值。 這兩種遞增操作的主要差異就是返回值的順序。如果需要先使用變數的當前值，然後再遞增，則應使用後遞增 (value++)。如果要先遞增變數的值，然後再使用新的值，則應使用先遞增 (++value)。在先遞增的情況下，變數的值會在遞增前被修改，而在後遞增的情況下，變數的值會在遞增後被修改。 簡而言之就是根據遞增和遞減運算子是位於運算元之前或之後，執行方式會有所不同。 重點整理今天主要都在介紹運算子，然後新的知識點是先遞增和後遞增的差異：後遞增是先返回值再做後續的計算；先遞增是先進行運算操作後再返回值。除了學 C# 的東西也同時複習一下 JavaScript 的型別挺好的哈哈！那我們下次見ʘ‿ʘ 參考資料 C# 運算子 C# Certification with freeCodeCamp Challenge","link":"/2023/10/03/csharp-freecodecamp-challenge-04/"},{"title":"C# Challenge 05 - 引導式專案 - 計算和列印學生成績","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第五單元章節的內容。 本節內容建立變數以及做基本的數學運算，最後還有型別轉換等功能的總體練習，題目是幫每個學生的作業分數做一個加總的總和。下面是該練習的解題答案： 123456789101112131415161718192021222324252627282930313233343536373839404142// initialize variables - graded assignments int currentAssignments = 5;int sophia1 = 93;int sophia2 = 87;int sophia3 = 98;int sophia4 = 95;int sophia5 = 100;int nicolas1 = 80;int nicolas2 = 83;int nicolas3 = 82;int nicolas4 = 88;int nicolas5 = 85;int zahirah1 = 84;int zahirah2 = 96;int zahirah3 = 73;int zahirah4 = 85;int zahirah5 = 79;int jeong1 = 90;int jeong2 = 92;int jeong3 = 98;int jeong4 = 100;int jeong5 = 97;int sophiaSum = sophia1 + sophia2 + sophia3 + sophia4 + sophia5;int nicolasSum = nicolas1 + nicolas2 + nicolas3 + nicolas4 + nicolas5;int zahirahSum = zahirah1 + zahirah2 + zahirah3 + zahirah4 + zahirah5;int jeongSum = jeong1 + jeong2 + jeong3 + jeong4 + jeong5;decimal sophiaScore = (decimal) sophiaSum / currentAssignments;decimal nicolasScore = (decimal) nicolasSum / currentAssignments;decimal zahirahScore = (decimal) zahirahSum / currentAssignments;decimal jeongScore = (decimal) jeongSum / currentAssignments;Console.WriteLine(&quot;Student\\t\\tGrade\\n&quot;);Console.WriteLine(&quot;Sophia:\\t\\t&quot; + sophiaScore + &quot;\\tA&quot;);Console.WriteLine(&quot;Nicolas:\\t&quot; + nicolasScore + &quot;\\tB&quot;);Console.WriteLine(&quot;Zahirah:\\t&quot; + zahirahScore + &quot;\\tB&quot;);Console.WriteLine(&quot;Jeong:\\t\\t&quot; + jeongScore + &quot;\\tA&quot;); 重點整理這篇意外的沒什麼重點，大概就是前面四個章節大統整後的練習這樣。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/2023/10/04/csharp-freecodecamp-challenge-05/"}],"tags":[{"name":"Diary","slug":"Diary","link":"/tags/Diary/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"PersonalStuff","slug":"PersonalStuff","link":"/tags/PersonalStuff/"},{"name":"GoogleExtension","slug":"GoogleExtension","link":"/tags/GoogleExtension/"},{"name":"WebSecurity","slug":"WebSecurity","link":"/tags/WebSecurity/"},{"name":"E2E","slug":"E2E","link":"/tags/E2E/"},{"name":"Testing","slug":"Testing","link":"/tags/Testing/"},{"name":"UnitTest","slug":"UnitTest","link":"/tags/UnitTest/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"CodeCamp","slug":"CodeCamp","link":"/tags/CodeCamp/"},{"name":"Microsoft","slug":"Microsoft","link":"/tags/Microsoft/"},{"name":"Challenge","slug":"Challenge","link":"/tags/Challenge/"},{"name":"Certification","slug":"Certification","link":"/tags/Certification/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Debounce","slug":"Debounce","link":"/tags/Debounce/"},{"name":"Thorttle","slug":"Thorttle","link":"/tags/Thorttle/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"Swagger","slug":"Swagger","link":"/tags/Swagger/"},{"name":"BlankSpace","slug":"BlankSpace","link":"/tags/BlankSpace/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"空白","slug":"空白","link":"/tags/%E7%A9%BA%E7%99%BD/"},{"name":"Hexadecimal","slug":"Hexadecimal","link":"/tags/Hexadecimal/"},{"name":"Hexi","slug":"Hexi","link":"/tags/Hexi/"},{"name":"NumberingSystem","slug":"NumberingSystem","link":"/tags/NumberingSystem/"},{"name":"16進位","slug":"16進位","link":"/tags/16%E9%80%B2%E4%BD%8D/"},{"name":"CS","slug":"CS","link":"/tags/CS/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Style","slug":"Style","link":"/tags/Style/"},{"name":"Blogger","slug":"Blogger","link":"/tags/Blogger/"},{"name":"Kata","slug":"Kata","link":"/tags/Kata/"},{"name":"Codewars","slug":"Codewars","link":"/tags/Codewars/"},{"name":"KataPractice","slug":"KataPractice","link":"/tags/KataPractice/"},{"name":"Fundamentals","slug":"Fundamentals","link":"/tags/Fundamentals/"},{"name":"React.js","slug":"React-js","link":"/tags/React-js/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"},{"name":"Learning","slug":"Learning","link":"/tags/Learning/"},{"name":"FrontEnd","slug":"FrontEnd","link":"/tags/FrontEnd/"},{"name":"Note","slug":"Note","link":"/tags/Note/"},{"name":"Agile","slug":"Agile","link":"/tags/Agile/"},{"name":"Scrum","slug":"Scrum","link":"/tags/Scrum/"},{"name":"ScrumMaster","slug":"ScrumMaster","link":"/tags/ScrumMaster/"},{"name":"ProductOwner","slug":"ProductOwner","link":"/tags/ProductOwner/"},{"name":"DevelopementTeam","slug":"DevelopementTeam","link":"/tags/DevelopementTeam/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"VueDirective","slug":"VueDirective","link":"/tags/VueDirective/"},{"name":"事件綁定","slug":"事件綁定","link":"/tags/%E4%BA%8B%E4%BB%B6%E7%B6%81%E5%AE%9A/"},{"name":"指令","slug":"指令","link":"/tags/%E6%8C%87%E4%BB%A4/"},{"name":"v-on","slug":"v-on","link":"/tags/v-on/"},{"name":"WebDevelopment","slug":"WebDevelopment","link":"/tags/WebDevelopment/"},{"name":"GraphQL","slug":"GraphQL","link":"/tags/GraphQL/"},{"name":"RESTful","slug":"RESTful","link":"/tags/RESTful/"},{"name":"Design","slug":"Design","link":"/tags/Design/"},{"name":"NPM","slug":"NPM","link":"/tags/NPM/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"Version","slug":"Version","link":"/tags/Version/"},{"name":"Solution","slug":"Solution","link":"/tags/Solution/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"extension","slug":"extension","link":"/tags/extension/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"Jumpy","slug":"Jumpy","link":"/tags/Jumpy/"},{"name":"Program","slug":"Program","link":"/tags/Program/"},{"name":"Process","slug":"Process","link":"/tags/Process/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"Concurrent","slug":"Concurrent","link":"/tags/Concurrent/"},{"name":"Parallel","slug":"Parallel","link":"/tags/Parallel/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"ViewportUnit","slug":"ViewportUnit","link":"/tags/ViewportUnit/"},{"name":"svh","slug":"svh","link":"/tags/svh/"},{"name":"lvh","slug":"lvh","link":"/tags/lvh/"},{"name":"dvh","slug":"dvh","link":"/tags/dvh/"}],"categories":[{"name":"SuoChan&#39;s Log","slug":"SuoChan-s-Log","link":"/categories/SuoChan-s-Log/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Debug Series","slug":"Debug-Series","link":"/categories/Debug-Series/"},{"name":"CS Series","slug":"CS-Series","link":"/categories/CS-Series/"},{"name":"Kata Practice","slug":"Kata-Practice","link":"/categories/Kata-Practice/"},{"name":"React.js 30 Days","slug":"React-js-30-Days","link":"/categories/React-js-30-Days/"},{"name":"Scrum","slug":"Scrum","link":"/categories/Scrum/"},{"name":"Vue.js","slug":"Vue-js","link":"/categories/Vue-js/"},{"name":"C# Challenge","slug":"C-Challenge","link":"/categories/C-Challenge/"},{"name":"Web Development","slug":"Web-Development","link":"/categories/Web-Development/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"}],"pages":[{"title":"","text":"google-site-verification: google2e6edbdffdf9e909.html","link":"/google2e6edbdffdf9e909.html"}]}