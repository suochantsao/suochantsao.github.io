{"posts":[{"title":"20230724 log - Vimium","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點由於前公司有使用 Vim 的指令和操作，因此後來在自己的 IDE 和 Kata 練習的時候都會改成使用 Vim 的模式來撰寫程式碼。在還沒真正使用 Vim 之前完全搞不懂為何有人要特別去學習這種上古世代的指令，而且學習成本也高。不過在體會能夠快速透過 Vim 語法實現產品邏輯的時候才體會到了它的好。也真的是沒想過自己還會開始尋找 Vim 相關的套件或者是工具，實在很有趣！ 所以今天是來介紹我找到的一個 google 套件，叫做 Vimium - 一個可以在 google chrome 上面使用 Vim 的指令來瀏覽網頁的套件。 下面的參考資料會附上這個套件下載的網址，該套件的首頁是有作者親自錄製的常用快捷鍵導覽，基本上和我們使用 Vim 的指令是大致相同的，如果大家對 Vim 的指令有興趣的話，我可以再來整理。 雖然昨天才剛下載好，不過很明顯感受到自己使用滑鼠的頻率大幅降低了，整體感受挺不錯的，大家可以自己下載來試試看喔！那我們下次見ʘ‿ʘ 參考資料 Vimium 下載網址 如何提升鍵盤的使用效率？Vimium 讓你不用滑鼠，只使用鍵盤瀏覽與控制網頁","link":"/20230724/20230724-log/"},{"title":"20230726 log - Web Security","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點最近透過以前追蹤的一些軟體開發者的分享，開始對於資安的相關領域越來越有興趣。所以這幾天就是開始尋找一些比較入門的文章，看有沒有比較適合初學者的學習路徑和內容？ 不過除了開始對新的領域產生好奇外，也會有點擔心前端以及今年上半年主力研究的後端是不是需要先擱置在一旁？感覺自己踏入了這個軟體開發的領域之後就時不時的產生這樣子的焦慮，深怕自己一個不小心就被產業變遷的速度給沖走了。 但現階段來說，可能因為今年是相對變動比較大的 – 不管是喜或憂的部分，所以還是會希望能夠找到一個自己能夠真正的發揮所長或長才的舞台，因此這樣的擔憂出現確實也是有它的原因存在。 預計下週開始會整理一些資安相關的文章資源在這，就下週再來更新囉！那我們下次見ʘ‿ʘ","link":"/20230727/20230726-log/"},{"title":"20230731 log","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點今天整理了一些資安相關的鐵人賽文章以及網路上的優文分享給大家，除了補充一點資安相關的知識以外，其實也打算把這樣的概念融入到自己新的 side project 中。 另外針對新的 side project 也想加入 unit test 至其中，但目前尚未有實際使用過的經驗，所以預計這週會花點時間琢磨在 unit test 相關的 framework 來好好的比較一下，最後再來決定要使用哪一個？那我們下次見ʘ‿ʘ 參考資料 生活資安五四三！從生活周遭看風險與資訊安全～番外篇 資安x系統x絕對領域 [很不鐵人的 IT 鐵人賽] 前端工程師學資訊安全","link":"/20230731/20230731-log/"},{"title":"20230804 log - Web Check","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點今天跟大家分享我在 Twitter ( 現名為 X ) 看到的一個網站檢測工具 - Web Check , 你可以在 input 的欄位裡輸入您想調查的網址，就可以知道該網域目前的機台所在地和該網站所使用的技術和資安相關設定的項目。 附圖是 Web Check 的畫面 大家可以試著貼上自己的網站或是好奇的網站來看看，挺有趣的！那我們下次見ʘ‿ʘ 參考資料 Web Check Web Check GitHub","link":"/20230804/20230804-log/"},{"title":"20230816 log - Vue3 and React todolist","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點這週讀書會跟大家討論一下接下來要學習的路徑，最後決定一起來學 TypeScript 了。雖然在前公司開發的時候是使用 Vue3 + TypeScript 沒錯，不過實際接觸到開發的功能其實沒有使用到邏輯的撰寫，所以嚴格來說對於 TypeScript 的理解還處於很基礎的程度。 這邊預計是下週讀書會的時候要一起分享各自寫的 Vue3 + TypeScript 的 todolist 寫法，有包含基本的 CRUD 還有 Done 的 filter 功能等。完成後就在更新到這邊來給大家參考吧！那我們下次見ʘ‿ʘ 參考資料 我的 GitHub Repository","link":"/20230831/20230816-log-Testing-tools/"},{"title":"20230802 log - 個人作品網站實作規劃","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點這幾天看到大家推薦要練習一個工具或是實作一個功能的話建議還是做一個簡易的專案來從中學習，所以明後兩天是規劃要先練習 React 的 Todolist 之後，再使用 React 實作一個個人的作品網站。 目前預計要使用在個人的作品網站的技術有以下幾個： i18n 多國語系 night mode 的模式切換 Unit test ( Vitest / Playwright) animation.js CI/CD (GitHub Actions) 以上是目前預計要使用到的技術或工具，至少身為一個網頁軟體工程師我覺得上述的這幾個功能算是蠻基礎且必要的。接下來幾天就陸續跟大家更新我的實作進度囉！那我們下次見ʘ‿ʘ","link":"/20230802/20230802-log/"},{"title":"20230901 log - C# workshop","text":"每週一至五，使用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點前幾天在 FB 上看到這個 C# 的官方挑戰課程，剛好在練習了 kata 完之後可以接續這個內容。目前計畫是在自己生日之前要完成這個學習計畫，也期許自己能慢慢的朝全端之路前進，今天會是學習計畫的第一天，如果大家對這個課程有興趣的話我將上課的連結提供在下方。 P.S 這個課程是 Micosoft 官方所推出的，要上課前要記得先註冊一個 Microsoft 的帳號唷！ 那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20230901/20230901-log-C-workshop/"},{"title":"C# Challenge 01 -  撰寫您的第一個 C# 程式碼","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第一單元章節的內容。 單元重點今天完成了 Microsoft 的 challenge 第一單元，基本上沒有太多的知識量，介紹了 C# 這個程式語言的基本知識還有編譯器的作用是什麼等等。 不過硬要指出一個缺點的話就是這個 challenge 有一些頁面或是課程的翻譯是用機器或 AI 翻譯的，所以在一些課程的說明文件和問答的語意上會呈現比較不能理解的意思。但沒有到太影響到我的學習，所以整體來說還是算可以的，可是畢竟我目前只有上了一個單元，之後可能還要再陸續觀察一下其他單元的狀況。 一樣把上課的連結放在參考資料裡面，有興趣的大家可以自己去報名參加喔！那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20230906/C-01-course/"},{"title":"防抖 ( Debounce ) 和節流 ( Thorttle )","text":"會找到這篇文章的你，應該是在近期聽到了這兩個名詞對吧？我其實是在上週的面試過程中被問到了這個對當時的我來說非常陌生的兩個詞。一起來看什麼是 JS 的防抖和節流吧！ 名詞介紹開門見山的說，這兩種方法其實都是為了降低網頁在短時間內重複觸發 Function 太多次所造成的效能浪費，所以簡而言之他們的出現其實就是為了減少沒必要的監聽事件所觸發的次數。那下面就來一起看一下防抖和節流分別是怎麼處理這樣的需求的？ 防抖 Debounce什麼是防抖 Debounce ? 當我們所監聽的事件在固定的時間長度內再次被觸發時重新計算該時間長度，直到該時間長度結束時沒有再發生監聽的事件後才會確實執行該函式。 這樣講可能比較抽象，以生活化一點的例子來舉例的話就像是大賣場或是捷運裡面的電扶梯：當電扶梯的感應器偵測到有人踩上踏階時，它就會持續地運轉讓乘客移動到不同的樓層。但是當它的感應器一段時間（可能是 5 分鐘？我也不確定）都沒有偵測到任何人走到電扶梯的踏階上時，它就會觸發待機模式，並將電扶梯調整為較低的轉速。 所以這邊待機模式的觸發條件設定，就是利用防抖 Debounce 這個概念，否則如果每個乘客中間都一直觸發待機模式然後再重新啟動調整為正常速度的話，這樣對電扶梯也是一種耗損跟耗電的 實際應用範例 如果是以網頁常見功能來說明的話就是各大搜尋引擎的 Search Bar 了，在我們 key 入每一個關鍵字後，下方的搜尋引擎建議結果也是採用防抖的設計。 所以當你在頁面上快速鍵入許多單字觸發了 keyin 或是 keyup 事件時時，它不會馬上就去資料庫拿出搜尋建議的結果，它會等到你輸入完且沒有再偵測到新的鍵入 event 時才將相關的搜尋建議渲染在 Search bar 下方。 節流 Thorttle什麼是節流 Thorttle ? 監聽到事件發生且經過一段固定的時間長度後，就會觸發該函式。 我們可以假設固定的時間長度為 5 秒，因此只要在監聽事件成立後這 5 秒內即使再次監聽到新的事件也不會影響它每 5 秒要執行一次的結果。 用一個生活化一點的例子來跟大家（還有自己）說明的話，就像是打 LOL 的時候每個英雄的四個招式還有兩個召喚師技能都會有它的 CD 時間，所以你如果觸發過上述的招式或技能時，你必須要等待它固定的冷卻時間結束後才能重新使用該技能。 實際應用範例 節流最常見的應用就是在各大社群媒體平台上面了，當我們想要看更多內容而滑至頁面底部時，會偵測到使用者目前已經瀏覽完我們提供的內容，這時候依照設定好的新內容數量再透過 API 發送請求，將新的內容渲染到下方。 結論就像開頭所說的那樣，防抖跟節流都是為了減少監聽事件過於頻繁的觸發所做的一種設計方式。其實我們在平常的開發或是 Side project 中可能曾經都有使用過這樣的概念來撰寫我們的 function ，只是從來沒有想過它是基於這兩個關鍵字來達成的。 寫越久的 code 真的越發現自己在不知不覺中也會碰到很多城市設計原則相關的內容呢！那我們下次見ʘ‿ʘ 參考資料 從動圖輕鬆解題：防抖與節流 函數防抖(Debounce) 與 函數節流(Throttle) 面试官：什么是防抖和节流？有什么区别？如何实现？ Debouncing &amp; Throttling in JavaScript How to Implement Debounce and Throttle with JavaScript","link":"/20230913/JavaScript-Debounce-and-Thorttle/"},{"title":"踩雷系列：%E2%80%8B 神奇的空白","text":"此篇文章同時收錄在我的 Medium 中，之後都會統一更新在 Hexo 這邊囉！ 事情是這樣發生的…上週和後端工程師開始進行專案的協作時，他提供了一份 Swagger UI 的文件讓我們做 API 的介接。一開始我就像撰寫其他專案一樣，將 Swagger UI 文件內所有的 API 統一複製貼上到 All.js 的檔案中，並在需要使用的頁面來介接。不過就在使用第一個 GET 的 API 時就出現 status 404 的狀況： 問題出在？ 通常出現 4 開頭的 status code 我就會確定是 client 端的問題，於是我就開始檢查我的 API URL 還有 axios 介接的方法有沒有寫錯？不過怎麼檢查程式碼和檢視 nuxt 的撰寫方式後都看不出來哪邊有問題和狀況？所以我就回頭看看 Console 視窗內的這個錯誤訊息，這才發現到一個很詭異的地方： 咦？ URL 中間怎麼多了幾個 %E2%80%8B 的字串？ 起初想說是不是 URL 自動將我的斜線編譯成 Unicode 了 ? 不過我又在 %E2%80%8B 後面看到了 / ，所以我就直接將 %E2%80%8B 這個字串丟到 Google 上去看了一下，究竟這是什麼鬼東西？ %E2%80%8B is the code for a “ZERO-WIDTH SPACE” character. 好！這下直接解開謎團了，原來是一個叫做 Zero-width space 的字元，中文翻譯也很直白，就叫做「零寬空格」。所以就如同字面上的意思，它是不會顯示出間隔的空格（怎麼有點饒口？） 使用 JS 的 decodeURI 將該編譯字元解碼後，可以看到解碼過後的空字串大家應該可以更加理解到什麼叫做「零寬空格」了吧？所以知道問題出在哪邊之後就開始著手更改這些因為懶得自己打的 API URL 而報錯的狀況了 解決方法如果專案內沒有太多的 API 那你可以先將複製貼上的 URL 移除後，再自行手動輸入即可（不要再偷懶ㄌ）。不過如果是像我一樣一次大量的複製貼上的你，那就只能用程式碼來解決了 1url = decodeURI(encodeURI(url).replace(/%E2%80%8B/g, '')) 記得在發送 Request 之前，將 URL 中的零寬空格使用空字串來取代。 後記後來在找解決方法的時候，確實在 Stack Overflow 上看到很多從 Swagger UI 文件上複製貼上 URL 的開發者也遇到相同的問題。也有蠻多人感嘆剛開始遇到這個問題真的百思不得其解？還跟後端對了好多次，透過 POSTMAN 等工具確認 API 介接都是正常無誤的，最後發現是這個問題的時候簡直傻眼的人也是不少。不過很幸運自己是在和後端求救之前有先找到問題點在哪的？ 開發的日子久了，什麼奇怪的 Bug 都能遇到呢 這系列果然算是蠻快就更新了希望大家很不幸遇到這個坑的時候可以馬上找到我這篇文章！那我們下次再見ʘ‿ʘ 參考資料菜雞抓蟲: Url 變得怪怪的？你可能是零寬空格（ZWSP）的受害者！ - 伊果的沒人看筆記本","link":"/20221128/blank-space-debug/"},{"title":"16 進位 ( Hexadecimal Number System )","text":"今天要來紀錄一下在撰寫 API 的時候第一次聽到的名詞： 十六進制 Hexadecimal 什麼是十六進制（ Hexadecimal ）？ 十六進制（ Hexadecimal ），也叫十六進位或者簡稱為 Hex ，是一種數字系統。這個數字系統總共使用了 16 個符號來表示數字，分別為：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F 等 16 個符號。 在十六進制中，每個位數的值就是 16 的次方，而每個位數都可以使用上面所列出的 16 個符號來表示。 從 A 開始代表的值為 10 ， B 為 11 ，以此類推 F 則為 15。 範例介紹假設在十進制的數字 15 ，它就會等同於十六進制中的 F 符號（ F 代表的值是 15 ）。若是在十進制中的數字 16，換成十六進制的數字時則為 10 。 為什麼是 10 ?因為在十六進制中，數字 10 中的 1 代表的是 16 的 1 次方，再加上了右邊的 0 代表的是 16 的 0 次方，兩者相加就為 16 ，這就是十進位中的數值了。 應用場景為什麼會在開 API 的時候遇到這個名詞呢？最主要的原因就是當初在設定回傳的 response 中會使用到十六進制的計算方式來計算我們的 API 中所回傳的資料長度，因此才知道了這個名詞。後來才知道在計算機概論和數字系統中，很常使用十六進制來表示二進制的數字。因為每個十六進制的數字可以表示出更多單位的二進制數字，所以才應用在這個領域當中。 那我們下次見ʘ‿ʘ","link":"/20230306/hexadecimal-hexi/"},{"title":"踩雷系列：ICARUS 的樣式設定檔案在哪裡？","text":"在 Hexo 技術部落格建好之後，開始想要微調一些樣式設定（蠻喜歡 Medium 那種簡約的風格），所以開始搜尋要怎麼修改我使用的樣式 ICARUS ，下面就來跟大家分享一下設定的內容： ICARUS 的樣式設定檔案位置樣式的檔案是在 node_modules 的資料夾內，資料夾的路徑是 hexo-theme-icarus/include/style這邊會建議大家新增一個自己的樣式檔案並在裡面填寫你修改的內容，當然也可以直接修改原始的 ICARUS 的樣式檔案。 為什麼這篇是放在踩雷系列？沒錯！應該有人會困惑說這篇看起來沒有任何的雷啊？但是我在修改樣式的初期一直找不到 ICARUS 的樣式檔案在哪邊？甚至還跑去修改編譯過後的 CSS 檔案，所以理所當然的，樣式是不可能有調整。因此我確實花了一段時間找到了原來樣式設定的檔案們在哪邊？確實有點搞笑 XD希望有使用 Hexo 搭配 ICARUS 的大大們都不要像我一樣找超久 QQ 修改的內容這邊有參考了其他網站的設定教學，調整了旁邊的 sidebar 和文章區塊的比例，因為教學文章很詳細，所以會附在下方的參考資料給大家！ 那我們下次見ʘ‿ʘ 參考資料Hexo - Icarus 主題 - 內容區塊寬度","link":"/20230208/icarus-style-file/"},{"title":"Kata Practice C# - DNA to RNA Conversion","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Deoxyribonucleic acid, DNA is the primary information storage molecule in biological systems. It is composed of four nucleic acid bases Guanine (‘G’), Cytosine (‘C’), Adenine (‘A’), and Thymine (‘T’). Ribonucleic acid, RNA, is the primary messenger molecule in cells. RNA differs slightly from DNA its chemical structure and contains no Thymine. In RNA Thymine is replaced by another nucleic acid Uracil (‘U’). Create a function which translates a given DNA string into RNA. For example: “GCAT” =&gt; “GCAU”The input string can be of arbitrary length - in particular, it may be empty. All input is guaranteed to be valid, i.e. each input string will only ever consist of ‘G’, ‘C’, ‘A’ and/or ‘T’. 自己的解法123456789namespace Converter { public class Converter { public string dnaToRna(string dna) { return dna.Replace('T','U'); } }} 解題脈絡按照問題的敘述先去 Google 找 C# 有沒有相對應的方法？於是就找到了 Replace 的這個方法，不過感覺這樣只是解決了基本的需求。當然這樣還是有符合題目的需求，但感覺應該還有更符合日常開發的狀況，所以就看了其他人的 Solution。 其他人的解法1234567891011121314namespace Converter { public class Converter { public string dnaToRna(string dna) { char[] dnaLetters = new char[4]{'G','C','A','T'}; string upperCaseDna = dna.ToUpper(); if(upperCaseDna.Any( letter =&gt; !dnaLetters.Contains(letter))) throw new ArgumentException(); return upperCaseDna.Replace('T','U'); } }} 選擇這個解法的原因雖然直接使用 Replace 可以完成需求，不過參考的這個 Solution 有將每一步的邏輯都整理起來，即便相較原本的寫法多了一些變數和判斷，但是這樣確有助於釐清整個程式碼的可讀性。即便不需要註解也可以知道這個 Class 在解決的問題是什麼？ 觀念釐清希望之後自己在練習 kata 的時候也能夠想到比較全面的練習，不僅僅是只符合題目的需求而已。 那我們下次見ʘ‿ʘ","link":"/20230518/kata-dna-to-rna-conversion/"},{"title":"終於建好了！我的 Hexo 技術部落格","text":"這是我的技術部落格的第一篇文章！實在是太感人了！講了好久的部落格一直都停留在想法的階段，但卻沒有真的去執行，直到前幾天發現了好多前端的前輩們都使用這個 Hexo 的套件快速建立網站後就決定著手開始了。 為什麼會想要建立技術部落格？其實最一開始我都是使用自己的 Notion 來做前端技術的筆記撰寫並建立起自己的技術資料庫，當初確實也有想過是否要將自己的筆記公開來，但是心中卻產生了一種如果我寫的是錯的怎麼辦？如果我誤人子弟怎麼辦？不過最後是在洧杰的一句話裡直接茅塞頓開： 想太多了吧！根本就不會有人看你的文章啦～ 所以就決定開始在自己的 Medium 發表一些技術文章和筆記，試著將自己學習的技術內容做紀錄，但也陸續發現關於 Medium 這個平台的一些狀況還有我個人的心理因素（又來！ Medium在 Medium 寫了幾篇文章後，確實有被一些人看到和獲得了拍手鼓勵，所以一開始是還蠻有成就感的。但是我漸漸發現該平台比較多英語使用者，加上大部分中文的文章也都屬於品質比較好的技術內容。 於是我漸漸發現，像是自己寫的這種筆記類型的文章好像不那麼適合在這個平台發布，所以就開始想說要自己建立一個技術部落格了。 自己架設部落格有了想要自己架設部落格的想法之後，就開始萌生出了許多要考量的點，像是： 網站的 UI 要設計成什麼樣子？ 需要有什麼功能方便使用者瀏覽文章？ 文章寫好之後要用什麼資料格式存放？ 整個部落格應該要放在哪個伺服器服務？ 想了一想，覺得這麼多東西要安排和規劃，那之後再說吧～ 對！就是這句之後再說吧的話就讓這個部落格計畫完全停滯不前，因為光想到上面列的那幾個問題就提不起勁要開工了 QQ 所幸在前幾天意外看到了 Ray 的鐵人賽文章 試著學 Hexo 後，才終於下定決心要來試著架設自己的技術部落格了。 Hexo於是照著鐵人賽文章裡面的內容開始安裝了 Hexo 並且逐步的將自己的部落格建立了起來，也意外發現其實蠻多前輩都是使用這個服務在撰寫自己的技術文章的。而且有了技術部落格之後內心突然覺得很踏實，終於有一個可以讓自己放心紀錄的平台了！ 關於部落格之後的走向？有大概想了一下這個部落格要發表的內容，不過其實不太想全部都侷限於技術的東西，有時候一直追技術也是頗累的XD所以之後應該會按照著這幾個大項目來做技術和其他日常的文章撰寫： 預計有的 Categories 技術文章系列：舉凡任何的框架、工具或程式語言的專門技術文章 踩雷系列：紀錄自己開發過程中遇到的 Bug 並祈禱不要太多人剛好需要這篇文章 SuoChan：紀錄身為前端工程師的日常或是一些心路歷程 目前想到的大項就是這三點了，或許之後會再新增也不一定？ 期許簡而言之，希望建立好這個部落格之後自己能慢慢的重回到渴望學習新技術和工具的狀態。 然後這篇文章沒有要教大家怎麼架設自己 Hexo 部落格喔！之後確實會透過文章紀錄我是怎麼從無到有建立的，但如果已經等不及的話可以先參考上面 Ray 的鐵人賽文章。那我們下次見ʘ‿ʘ 參考資料 試著學 Hexo 系列 Markdown 教學","link":"/20221105/personasl-hexo-blog/"},{"title":"React.js 學習記錄：什麼是 React.js ?","text":"此篇文章同時收錄在我的 鐵人賽文章 - React.js 30 天學習全記錄 中，之後會同步更新在 Hexo 這邊唷！ 我自己在學習新技術的時候比較習慣先暸解一下這個技術的基本概念還有它解決了什麼問題。所以今天我要跟大家一起來看 React.js 到底是什麼？它又能夠幫我們做什麼呢？ 什麼是 React.js ? A JavaScript library for building user interfaces. 沒錯！從官網進去後，印入眼簾的就是這段話。所以 React.js 其實就是一個用來打造 UI 的 JavaScript 函式庫，而且它是由 Facebook 團隊所開發出來的。在 Facebook Open Source 中不只有 React.js 而已，現今撰寫 APP 常用到的框架 React Native 也是由他們所開發的（在 Facebook Open Source 的網站中可以瀏覽其他由該團隊開發的框架和函式庫）。 框架 Framework？ 函式庫 Library？隨著網頁開發的功能越來越多元、內容也越來越複雜後，工程師們為了解決開發上衍生出的種種問題而寫出解決這些狀況的框架和函式庫。不過看了那麼多資料跟介紹不斷地提及框架和函式庫，我真的每次都被搞得頭昏眼花。結果就在搜集資料和瀏覽文章的時候看到了這篇文章仔細地分析了究竟這兩者的差別在哪？ 差異在於，使用「框架」的話，框架具有控制權，而身為這份軟體的開發者，你需要依照框架的設計把功能填上，填完的之後，程式便會照你的意思運作了；「函式庫」則是不同的，它像是一個彈藥庫，裡面藏有各種武器供你使用，你有控制權去決定怎麼使用它們，甚至不使用。 看完這段敘述之後我們大概可以了解這兩者之間的差異了吧？想想看以前在練習 Side Project 的時候如果遇到不會的功能，可能會去 CodePen 上面找看看別人的範例。而這些範例當中會有些人在特定的地方使用到 jQuery 這個 函式庫 (library) 但是並不一定所有的內容都會使用到（可能一部分是寫原生的 JavaScript ）。不過當你是使用 Vue.js 這個 框架 (Framework) 的時候，就是必須按照它設定好的環境來撰寫特定的語法來開發整個功能。 所以你有發現一件事情嗎？在你見過的大多數資料內所提及目前的前端三大框架 Angular 、 Vue.js 以及 React.js 中， 其實有一個根本就不是框架而是函式庫，它就是 React.js ！ React.js 可以解決什麼問題？透過上面的內容我們現在對 React.js 可以說是有初步的認識了，但是所有的工具（不管是框架或函式庫）被開發出來都是為了要解決問題，讓我們能夠更便利更快速地進行前端開發。講了這麼多，所以 React.js 到底提供了哪些功能來幫助我們呢？ 要了解它能幫你解決什麼問題前，你其實應該先問問自己一個問題：在最一開始學習 JavaScript 做前端開發時遇到了哪些狀況？ 這邊先列幾個我曾經寫原生 JavaScript 寫到懷疑人生的時候遇到的狀況給大家作為參考： 設定很多 DOM ，光想命名就崩潰。之後除了要監聽事件，還要注意綁定的 DOM 是否正確？否則也監聽不到。 不斷地在渲染(Render)畫面。如果要渲染的區塊比較多資料的話，程式碼就會看起來又臭又長。 有些功能類似的開發，因為資料還是有些微的不一樣就一直重複撰寫相似的內容。 以上就是我目前想到當初在使用原生 JavaScript 開發的時候遇到的難處和困擾。當然我相信這不會是只有我一個人遇到的狀況，所以這些開發困境也是讓後來許許多多的 JavaScript 框架和函式庫不斷出現的原因。 所以知道自己的問題在哪之後，我們就來看看 React.js 這個函式庫究竟提供了什麼樣的方法來幫助我們脫離上面的種種困境呢？ React.js 的兩大特色 宣告式 Declarative 在 React.js 中的 View 是採用宣告的方式並使用 Virtual DOM 的概念來進行綁定和渲染。它會在資料有變更時更有效率的自動更新並渲染 （Render） 所有有產生變動的元件。簡單來說，這代表當我的資料或內容有更新的時候，我不再需要去重新渲染出整個區塊的資料，而是透過宣告式的 View 來直接幫我更新畫面上那些有變更的資料而且需要重新渲染的部分即可。 所以這部分就解決了我們前面提到不斷的再重新渲染頁面的問題了。 元件式開發 Component-Based React.js 是以 元件為基礎 來做開發的，因此你可以自行定義不同的元件並設定每個元件不同的狀態（state），以及透過傳送給子元件（props）的方式來進行資料的傳遞。而基於這樣的元件基礎開發模式之下，我們就可以將網站中會重複利用的東西（像是按鈕等）定義成一個元件，並針對不同用途或功能去做設定資料（像是按鈕上面的文字）。 所以這部分則是解決了原生 JavaScript 在開發上會重複撰寫相同功能但是不同資料的東西，大大的簡化程式碼之外也提升了可閱讀性和之後要修改的便利性。 以上都是 React.js 為我們提供的強大功能，不過還有很多等著我們探索的地方，所以就繼續讀下去吧！另外有任何問題都非常非常歡迎提出和指教唷～那我們下篇見ʘ‿ʘ","link":"/20230122/reactjs-learning-whats-framework-library/"},{"title":"Kata Practice C# - Opposites Attract","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Timmy &amp; Sarah think they are in love, but around where they live, they will only know once they pick a flower each. If one of the flowers has an even number of petals and the other has an odd number of petals it means they are in love. Write a function that will take the number of petals of each flower and return true if they are in love and false if they aren’t. 123456789using System;public class LoveDetector{ public static bool lovefunc(int flower1, int flower2) { //Moment of truth... }} 自己的解法123456789101112131415using System;public class LoveDetector{ public static bool lovefunc(int flower1, int flower2) { if( flower1 % 2 == 0 &amp;&amp; flower2 % 2 == 0 ){ return false; } else if ( flower1 % 2 != 0 &amp;&amp; flower2 % 2 != 0){ return false; } return true; }} 解題脈絡一開始就是照著題目的 Description 來寫，所以其實程式碼很直觀，但換個說法就是爛到不行哈哈！不過我覺得對於自己目前的程度來說就是盡量地用自己現有的思維去寫，然後再透過大家的 Solution 來學習別人寫程式的邏輯。可以備註的地方應該是在解題時我就有知道這樣的解法不是最佳解，這樣就是把所有的條件都各別列出來而已。 其他人的解法123456789using System;public class LoveDetector { public static bool lovefunc(int flower1, int flower2) { return (flower1 + flower2) % 2 == 1; } } 選擇這個解法的原因這邊的話會盡量選擇自己看得懂而且能夠理解的寫法來做紀錄，其實同樣的練習可能還有你認為更好的做法，那這部分你可以透過自己解題 Submit 後再去參考其他人的。會選擇這個解法的原因是 flower1 + flower2 如果被 2 取餘數是 1 的話就代表這兩個參數有一個不是雙數了，因此兩個雙數相加後取餘數就會等於 0 並符合題目要求的返回 False 的值。 觀念釐清後來發現是自己沒有搞清楚 % 這個算術運算子的功能其實是取餘數，所以才繞了一大圈把所有的條件都寫出來，雖然有點丟臉但不過現在也因此加深印象了 XD 那我們下次見ʘ‿ʘ","link":"/20230513/kata-opposites-attract/"},{"title":"33355 ? Scrum 中的第一個 3 - 三個角色","text":"這一篇要來跟大家分享的是基於 Agile 敏捷開發的 Scrum 框架中的 3 個角色有哪些？如果對於 Scrum 這個概念有點不是很了解的地方，之後會再另外整理一篇文章跟大家說明，這篇會著重在介紹究竟有哪些角色？他們分別又負責了哪些工作內容？讓我們繼續看下去 … Scrum 中的三個角色在執行 Scrum 的團隊當中，會有三個不同的角色執行不同的任務與職責來確保團隊的開發能夠順利地按照規劃來執行。那下面我們就來看一下這三個角色分別為何？ Product Owner 產品負責人通常在團隊中也會簡稱為英文單字的縮寫 PO ，下面就用 PO 代稱產品負責人。 PO 最主要的職責就是作為客戶與團隊之間的橋樑，需要瞭解客戶目前的需求以及期望獲得解決的方案等等，因此 PO 在釐清客戶需求的同時也必須確保開發團隊能夠確實知道客戶需要的功能或是服務是什麼？ 並且將每個需求的優先順序排列出來，讓開發團隊知道每個任務的優先順序是什麼以及為什麼？ PO 這個角色在我還沒有加入有導入 Scrum 的團隊時，我一直覺得這個職位和 PM 是相同的。不過在加入我們公司的 Scrum 團隊後發現 PO 對於客戶的需求必須有更進一步的理解，因為他必須能夠幫客戶判斷這個功能的優先程度是什麼？這樣開發團隊才能依照輕重緩急和順序來做開發，完成需要交付給客人的產品。 Development Team 開發團隊 在 Scrum 當中的開發團隊不只有軟體工程師，舉凡所有會跟開發工作相關的跨職能職位都會包含在這個團隊中，像是 UI 或是測試等項目都包含在其中。其職責最主要就是要順利完成每一次 Sprint 所設定目標 ( Sprint Goal )，並互相幫忙和提出意見以確保團隊都能一起解決定好的目標和問題。 在 Scrum 中的開發團隊會以 Team 的目標為首要任務，在這樣的團隊裡面不需要互相競爭比較，而是會將目光放到團隊要解決的問題上，變成一個以團隊為核心的概念。 Scrum Master唯一一個沒有翻譯成中文的角色，通常在團隊內都會直接稱做 Scrum Master 或是簡稱 SM ，下面就統一使用 SM 稱呼。 SM 就像是執行 Scrum 的教練，他會參與整個團隊的會議並且確保 Scrum 能夠順利的在團隊內執行，同時也會在過程當中給予一些會議流程或是方法上的改善與建議。 這邊要特別注意的是，雖然 SM 在團隊當中應該算是最透徹了解 Scrum 框架該怎麼執行的一個職位，不過在團隊中他僅能夠作為一個就他所觀察到的一些問題或是能夠優化的流程提出他專業意見的人，而要不要採納 SM 的建議以及解決方案則是決定在開發團隊本身，他並沒有權利叫團隊該如何進行會議或開發。 在公司內部有發現許多不同背景的人轉職成為 SM ，而不同背景出身的 SM 也會帶來許多不同的火花。像是我們團隊的 SM 就是從工程師背景轉過來的，因此他在提出一些想法和意見的時候就能夠用更貼近開發團隊的思維來提供，這點我個人覺得是一個蠻不錯的優勢。 SM 的職責還有這個職位實際上要點的技能樹有哪些？我還沒有完全的了解，之後再找時間把這塊知識給補上（或是請教 ChatGPT 好朋友） 結語接下來還會有四篇的文章來說明這個 Scrum 框架的口訣 33355 後面的四個數字分別代表什麼？有寫錯或是語意不通順還是不理解的部分歡迎大家踴躍留言，也感謝讀到這邊的各位大大，希望有為你們解惑唷！那我們下次見ʘ‿ʘ 參考資料 [DAY 09]角色設定01:Scrum三角色 一些產品負責人的怪味道 – 談Scrum Product Owner常見的誤區","link":"/20230216/scrum-framework-three-roles/"},{"title":"Vue.js : v-on 事件綁定指令","text":"v-on 是一個 Vue.js 的事件指令，是用來綁定在 DOM 上做為事件監聽和執行指定函式的功能。 v-on 的實作v-on 的寫法為 v-on:事件名稱=”執行的函式” ，其實這就等同於我們使用 JavaScript 所撰寫的 querySelector 以及 addEventListener 這兩個功能。 JavaScript 寫法12// HTML&lt;button class=&quot;btn-add&quot; /&gt; 123// JavaScriptconst addButton = document.querySelector('.btn-add');addButton.addEventListener('click', count++) 先在 HTML 建立 class 或是 id 名稱（建議使用 class 名稱），並在 JavaScript 的檔案中綁定指定的 DOM 的 class 或是 id 名稱後再使用 addEventListener 來監聽指定的 click 事件，並執行 count++ 這個函式。 v-on 寫法1234&lt;template&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;button class=&quot;btn-add&quot; v-on:click=&quot;count++&quot; /&gt;&lt;/template&gt; 直接在要綁定監聽事件的 DOM 上使用 v-on 的指令之後，加上要監聽的事件名稱和要執行的函式即可。 v-on 的簡寫實務上不大會使用 v-on:事件名稱=”執行的函式” 這樣的寫法，比較常使用的是 @事件名稱=”執行的函式” （貫徹工程師能省則省的簡單寫法）。 1234&lt;template&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;button class=&quot;btn-add&quot; @click=&quot;count++&quot; /&gt;&lt;/template&gt; 那我們下次見ʘ‿ʘ","link":"/20230104/vuejs-von-directive/"},{"title":"C# Challenge 02 - 在 C# 中使用常值與變數值來儲存及擷取資料","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第二單元章節的內容。 本節內容C# 型別 char：單一字元，在使用和宣告時是採用單引號的方式。 string：字串，在使用和宣告時是採用雙引號的方式。 int：整數，在使用和宣告時不需要採用特殊的方式，直接輸入數字即可。 浮點數：根據小數點的數目，再細分為三種類別 float: ~6-9 digits double: ~15-17 digits decimal: 28-29 digits，記得在數字的最後加上 m 或 M。 bool：布林值。 變數的命名規則 變數名稱可包含英數字元與底線字元。 不能使用井字號 # 或貨幣符號 $ 之類的特殊字元。 變數名稱的開頭必須是字母或底線，而不是數字。 變數名稱會區分大小寫，這表示 string Value; 與 string value; 是兩個不同的變數。 變數名稱不得為 C# 關鍵字。 例如：decimal decimal; 或 string string;。 var 關鍵字使用使用 var 關鍵字來宣告變數時，請務必初始化該變數的值，否則會看到 output 中的錯誤訊息。 重點整理主要注重在變數的資料型別以及該如何宣告，個人覺得 C# 的資料型別上在小數點跟字串的部分都更加的詳細，可能要花點時間適應。畢竟寫了太久的弱型別 JavaScript 實在不太習慣在宣告變數時就要加上型別的操作，但相信這絕對是個好的開發形貫的養成的！那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20230922/C-02-Challenge/"},{"title":"GraphQL 是什麼？ GraphQL &amp; RESTful API 的差異","text":"近幾個月求職的時候越來越常在 JD 和面試的時候被問到關於 GraphQL 的相關概念，所以就決定開始來研究 GraphQL 究竟是什麼？它能應用到的場景是哪些？一起來一探究竟囉！ 什麼是 GraphQL ? A query language for your API. 進入官網斗大的標題就直接明瞭的告訴你了，不過我必須承認我在研究這個主題時看到這句話其實是滿頭問號的。原因很簡單，因為我不知道為什麼需要查詢我的 API ，所以在解釋 GraphQL 前，我們應該要先來了解一下 GraphQL 是為了解決什麼問題而誕生的？ 還沒有 GraphQL 的時代 在 GraphQL 出現之前，API 設計通常會選擇使用 RESTful 的設計風格，這種風格的 API 具有固定的端點結構且每個端點代表一個資源，並且使用 HTTP 方法（ GET / POST / PUT / DELETE 等 methods ）執行操作。這種方式有其優勢，但也存在一些限制，特別是當客戶端需要不同組合的數據或自定義查詢時。 這邊的端點指的就是 API 中固定的 URL 結構，像是： 獲取所有用戶：/api/users 獲取單個用戶：/api/users/{userId} GraphQL 解決的問題 所以 GraphQL 的核心功能之一：讓用戶可以根據自身的需求自定義要查詢的項目，而不需要像 RESTful API 遵循固定的端點結構，讓其他不相關的資料也一併回傳。 看一下下面的 GraphQL 的 request 範例： 123456789101112POST /graphqlContent-Type: application/json{ &quot;query&quot;: &quot;{ user(id: 1) { id name email } }&quot;} 可以發現我們的 API 端點 url 統一為 /graphql ，而在 request 中我們可以直接指定我們只要 id 為 1 的使用者資料，其他的使用者資料都不需要回傳過來。 這邊可能有人會好奇說，這樣不是跟 RESTful API 一樣嗎？只是我在 url 上面要多帶一個 id 的參數就好。 不過這也直接點出了 RESTful API 的劣勢，你必須根據請求端需要的資料來做設計不同的端點，但是 GraphQL 在端點的部分都統一，讓我們直接從 client 端去選擇自己要收到的 response 是什麼？ 所以 GraphQL 到底是？ GraphQL 不只是一種查詢 API 的語言，它也是用於建立靈活、高效、精確數據API的工具，同時還是一個執行引擎，用來負責解析和執行這些查詢。 希望透過上面的說明大家可以更知道 GraphQL 在做什麼？ 因為我之前很常把它跟 RESTful API 搞混，所以才特別把這些我當初困惑的問題都整理出來。 GraphQL 和 RESTful API 的差異 差異 GraphQL RESTful API API 端點 用戶可以通過一個單一的端點發出具體的查詢來擷取所需的數據，而不需要多個不同的端點。 使用多個不同的端點（資源路徑）來執行特定操作。每個端點通常代表一個特定的資源和操作（GET、POST、PUT、DELETE等）。 過度請求 使用查詢語言使得過度請求的狀況出現時相較容易控制，因為 client side 可以精確的指定所需要的資料即可。 如果遇到過度請求問題通常需要通過創建不同的端點或自定義參數來解決。 版本管理 通常不需要版本管理，因為 client side 可以根據需求撰寫新的 query。 比較需要版本管理，以確保現有的 client side 能正確取得 response，且當 API 發生新的需求必須變更時，通常就要創一個新版本的端點。 結語直接引用 ChatGPT 幫我做的結論 GraphQL 是一個用於設計和實現API的工具，它的核心是 查詢語言和執行引擎 ，讓客戶端能夠根據其需求自定義查詢。而 RESTful API 則是一種特定的 API 設計風格，它遵循 REST 原則，使用 HTTP 方法來執行操作。這兩者在設計和使用上有很大不同，可以根據項目的需求選擇適當的工具和風格。 總算搞懂了這個工具到底在做些什麼？雖然目前都還沒在工作上接觸到，不過對 GraphQL 的印象確實很不錯，希望之後有機會可以實際使用到。那我們下次見ʘ‿ʘ 參考資料 GraphQL 什麼是 GraphQL？ 為什麼要學 GraphQL? GraphQL 和 REST 有何區別？ GraphQL是什麼？給新手的入門教學指南","link":"/20230922/graphql-restful-api-design/"},{"title":"NPM 更新後所有指令都失效了？ NPM 和 Node.js 版本號支援問題","text":"踩雷系列全部的題材保證都是本人親自踩過的，希望各位如果剛好不幸遇到的話也能夠幸運的找到我的這篇文章幫你解惑！ 事件經過又是一個平凡的開發日常，打開自己電腦內的 iTerm 時看到了一個 npm 的更新通知，索性就輸入 npm install -g npm 來安裝更新檔。結果更新完後要使用 npm run dev 執行自己的 Vue3 專案時看到了以下的畫面： 一個錯誤訊息跳了出來 1Error: Cannot find module 'timers/promises' 這時候我嘗試去執行其他的專案也通通遇到一樣的錯誤訊息，於是就開始 google 和 Stack Overflow 來尋找答案的旅程了。 踩到的雷最後在這篇文章 Error: Cannot find module ‘timers/promises‘ 找到了踩到的雷是什麼？原來是因為升級後的 npm 沒辦法支援現在本地端 node 的版本，所以版本相互不支援的情況間接導致我沒辦法順利執行所有 npm 相關的指令。 解決方法於是我就去查了一下目前可以支援這個 npm 版本的 node 版本有哪些？ 並指用 nvm 這個 node 版本管理工具將當前的 node 版本更新為有支援的 node 18 後就順利解決了。 後記後來發現，其實在我一開始升級完 npm 之後， iTerm 就有顯示 Warning 的訊息告訴我，更新後的 npm 和我本地端目前的 node 版本是不支援的，必須同步將 node 一起升級才可以。所以看到這邊你可能會想說，究竟是我踩到了雷還是我自己就是那個雷呢？Who knows? 哈哈哈哈哈 那我們下次見ʘ‿ʘ 參考資料Cannot find module ‘timers/promises’","link":"/20230923/npm-node-version-error-problem-solution/"},{"title":"VSCode extension 遇到 Jumpy 和 Vim 的衝突事件","text":"踩雷系列全部的題材保證都是本人親自踩過的，希望各位如果剛好不幸遇到的話也能夠幸運的找到我的這篇文章幫你解惑！ 事件經過最近在著手練習 React + TypeScript 的內容時，看到了技術文章內有推薦適合這個框架組合的開發者一些 VS Code 的套件，這時候看到了之前在 Rider 這個 IDE 中有使用過的 AceJump 套件，能夠讓你快速地跳到指定字元的位置做編輯或撰寫程式碼。在 VS Code 中的套件名稱為 Jumpy ，了解了該如何使用後就下載安裝了起來。結果要開始使用的時候就發現，當提示的反光字元出現時，我沒辦法輸入字元去跳至對應的位置。所以就開始 Debug 了。 踩到的雷最後在 Jumpy 的 GitHub Page 中的 Issues 看到了這個討論，發現如果你有在 VS Code 中安裝 VSCodeVim 這個套件的話，你無法順利的執行 Jumpy ，因為他會在你輸入指定字元的時候觸發到 Vim 的指定。 解決方法 後來在上面所提及的討論串當中發現有一位作者直接將原本的 Jumpy 重新開發一個新的 Jumpy2 ，讓 VSCodeVim 的使用者可以同時使用這兩個套件不衝突，真是暴力又直接的解決方式ㄚ 後記這次的踩雷讓我發現，開發日子在久了之後真的就是一直不斷的在面對這種版本衝突和不支援的狀況中度過。希望之後的開發遇到這種問題時不要卡關太久，都能順利解決！ 那我們下次見ʘ‿ʘ 參考資料 Jumpy Jumpy GitHub Page Jumpy2","link":"/20230923/vscode-extension-vim-jumpy-solution/"},{"title":"終於等到了！CSS 新 viewport 單位 svh &#x2F; lvh &#x2F; dvh","text":"原本在我的 medium 預定排程中要撰寫的一篇文章就是我自己製作 side project 時遇到 Safari 100vh 的神奇之處，想不到還沒有等到我懶癌康復的那天到來，CSS 就直接推出新的 viewport 單位讓大家以後一勞永逸了。廢話太多，趕快一起來看新單位有多香吧！ 現有的單位目前我們前端在做切版的時候，如果需要使用滿版的樣式時大部分會採用 vh 這個單位來滿足這個需求，可是你一定有遇過下面這樣的鬼故事： 遇到的災情當你使用 height: 100vh 來設定滿版的高度時，你會在移動端的地方發現有個詭異的狀況。在不同瀏覽器中，它顯示出的畫面會不大一樣，而原因是出在各家瀏覽器都有搜尋欄位和 domain 放置的地方會遮住部分的畫面，這個現象特別的地方在於它還指出現在 safari 上面（ 難怪一堆人說 safari 根本是現在版的 IE ）可是我們不可能去限制來瀏覽網站的使用者要用哪一款瀏覽器，所以還是要解決這個很無言但是又不可忽略的問題。 以下是網路上大家遇到的各種鬼故事紀錄（ 中英使用者皆有 ） 解決方法基本上當時大家都是直接使用 JS 去做動態的調整，畢竟每個瀏覽器的導覽列高度也都不盡相同，所以透過 JS 來判斷目前使用者的使用的瀏覽器之後在做 navbar 高度的計算處理和調整才能解決現有的需求。 不過現在有了新的 viewport 單位之後，以後就不用額外寫 JS 來判定可以交給心得 unit 來做就好ㄌ 新的 viewport 單位 上面這張圖是來自 Ahmad Shadeed 的 New Viewport Units 的文章，不只是寫得清楚明暸，再加上漂亮的文字間距和圖片說明，真的很優質！（優質到我差點懶得寫自己的筆記）不過還是大致跟大家說明一下這三個新的高度 viewport 的功能是什麼？ svh ( Small Viewport Height )svh 這個單位就是呈現出扣掉導覽列之後剩餘的高度，所以這邊的情況會用在導覽列一直存在的狀況下。 lvh ( Large Viewport Height )lvh 是用在導覽列往下縮之後的高度，你可以理解成整個移動端最大瀏覽區塊的高度。 dvh( Dynamic Viewport Height )dvh 會動態的根據你滑動手機時導覽列的縮放來調整顯示的高度，所以算是比較符合實務開發需求的新單位。 筆記心得新的 viewport 解決了以前開發移動端的鬼故事，但同時也感受到身在前後端（或是工程師領域）中的技術確實是日新月異。很開心自己身在這樣不斷變動的世界裡持續學習和努力，也期許自己能更佳理解和多多應用這些新的功能和方便的工具。那我們下次見ʘ‿ʘ 參考資料 New Viewport Units Safari’s 100vh Problem The trick to viewport units on mobile 使用100vh 在safari出现高度溢出问题与修复/ 100vh problem with ios safari","link":"/20231126/css-new-viewport-units-svh-lvh-dvh/"},{"title":"C# Challenge 03 - 在 C# 中執行基本字串格式設定","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第三單元章節的內容。 本節內容逸出 Escape 字元 要在字串資料中使用雙引號的話，使用 \\ 跳脫。12Console.WriteLine(&quot;Hello \\&quot;World\\&quot;!&quot;);// output: Hello &quot;World&quot;! 如果字串內已經含有 \\ 的話，使用兩個 \\ 跳脫。12Console.WriteLine(&quot;c:\\\\source\\\\repos&quot;);// output: c:\\source\\repos 使用 @ 指示詞建立逐字字串常值，並保留字串中的所有空白字元格式設定和反斜線字元。 1234Console.WriteLine(@&quot; c:\\source\\repos (this is where your code goes)&quot;);// output: c:\\source\\repos // (this is where your code goes) 使用 \\u 加上四字元代碼來代表字串中的 Unicode 字元 (UTF-16)。要注意：根據不同的系統或是設定有可能沒辦法正確顯示出來。 12Console.WriteLine(&quot;\\u3053\\u3093\\u306B\\u3061\\u306F World!&quot;);// output: こんにちは World! 字串結合變數 1234string firstName = &quot;Bob&quot;;string message = &quot;Hello &quot; + firstName;Console.WriteLine(message);// output: Hello Bob 字串組合簡寫 1234// 原始寫法string message = greeting + &quot; &quot; + firstName + &quot;!&quot;;// 精簡寫法string message = $&quot;{greeting} {firstName}!&quot;; 透過 $ 搭配雙引號來完成字串的組合，會更方便也更直觀一點，而且也有點類似 JavaScript 的樣板字面值。 重點整理今天重點都是放在字串跟變數的處理，我覺得最後的挑戰和知識檢定很棒，因為你可以檢視自己有沒有好好吸收這些內容。但最值得讚賞的部分是我覺得它這個 Challenge 的每個章節都不會太長，所以你可以有耐心地完成每一個課程，這真的很重要我覺得（大幅影響學習意願 XD ）。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231002/csharp-freecodecamp-challenge-03/"},{"title":"C# Challenge 04 - 針對 C# 中的數字執行基本作業","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第四單元章節的內容。 本節內容不同型別資料組合 1234string firstName = &quot;Bob&quot;;int widgetsSold = 7;Console.WriteLine(firstName + &quot; sold &quot; + widgetsSold + 7 + &quot; widgets.&quot;);// output: Bob sold 77 widgets. 編譯器會直接將所有 Console.WriteLine() 的內容視為字串，然後把它們全部串聯在一起。 但如果要將該字元視為數字進行運算時，可以使用 () 來表明這裡的值是要作為 int 來計算而不是 string 。 1234string firstName = &quot;Bob&quot;;int widgetsSold = 7;Console.WriteLine(firstName + &quot; sold &quot; + (widgetsSold + 7) + &quot; widgets.&quot;);// output: Bob sold 14 widgets. 基本運算子數學運算子 + 是加法運算子 - 是減法運算子 * 是乘法運算子 / 是除法運算子 小數點運算規則和型別 123decimal decimalQuotient = 7.0m / 5;Console.WriteLine($&quot;Decimal quotient: {decimalQuotient}&quot;);// output: Decimal quotient: 1.4 如果是小數點的資料要使用運算子的話，記得被除數或者是除數其中一個必須要是 decimal 的 type （或是兩者同時都是 decimal 也可以） 。 轉換型別後計算 但如果原本是 int 的資料型別卻想要做 decimal 小數點形式的資料轉換和計算的話，可以使用 (decimal) 來完成。 12345int first = 7;int second = 5;decimal quotient = (decimal)first / (decimal)second;Console.WriteLine(quotient);// output: 1.4 取餘數運算子 就是 % ，功能是計算資料後的餘數，如下面範例所示： 1234Console.WriteLine($&quot;Modulus of 200 / 5 : {200 % 5}&quot;);Console.WriteLine($&quot;Modulus of 7 / 5 : {7 % 5}&quot;);// output: Modulus of 200 / 5 : 0// output: Modulus of 7 / 5 : 2 運算子優先順序 Parentheses (括弧) : 必須先執行括弧內的內容 Exponents (指數) Multiplication (乘法) 與 Division (除法) : 由左至右 Addition (加法) 與 Subtraction (減法) : 由左至右 複合指派運算子 += 運算子會新增運算子右邊的值，並將其指派給運算子左邊的值。 int value = 0; // value is now 0. value = value + 5; // value is now 5. value += 5; // value is now 10. ++ 運算子會將變數的值遞增 1。 int value = 0; // value is now 0. value = value + 1; // value is now 1. value++; // value is now 2. 先遞增後遞增的範例這邊可以特別注意一下先遞增和後遞增的差異，附上 ChatGPT 的說明在下方。 int value = 1; value++; Console.WriteLine(&quot;First: &quot; + value); Console.WriteLine($&quot;Second: {value++}&quot;); Console.WriteLine(&quot;Third: &quot; + value); Console.WriteLine(&quot;Fourth: &quot; + (++value)); // output: First: 2 // Second: 2 // Third: 3 // Fourth: 4 先遞增(++value) ： 在進行遞增操作之前，首先會將變數的值加 1，然後返回遞增後的值。換句話說，先遞增操作會首先增加變數的值，然後返回新的值。 後遞增(value++) ： 在進行遞增操作之前，首先會返回變數的當前值，然後再將變數的值加 1。換句話說，後遞增操作會首先返回當前的值，然後再增加變數的值。 這兩種遞增操作的主要差異就是返回值的順序。如果需要先使用變數的當前值，然後再遞增，則應使用後遞增 (value++)。如果要先遞增變數的值，然後再使用新的值，則應使用先遞增 (++value)。在先遞增的情況下，變數的值會在遞增前被修改，而在後遞增的情況下，變數的值會在遞增後被修改。 簡而言之就是根據遞增和遞減運算子是位於運算元之前或之後，執行方式會有所不同。 重點整理今天主要都在介紹運算子，然後新的知識點是先遞增和後遞增的差異：後遞增是先返回值再做後續的計算；先遞增是先進行運算操作後再返回值。除了學 C# 的東西也同時複習一下 JavaScript 的型別挺好的哈哈！那我們下次見ʘ‿ʘ 參考資料 C# 運算子 C# Certification with freeCodeCamp Challenge","link":"/20231003/csharp-freecodecamp-challenge-04/"},{"title":"C# Challenge 05 - 引導式專案 - 計算和列印學生成績","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第五單元章節的內容。 本節內容建立變數以及做基本的數學運算，最後還有型別轉換等功能的總體練習，題目是幫每個學生的作業分數做一個加總的總和。下面是該練習的解題答案： 123456789101112131415161718192021222324252627282930313233343536373839404142// initialize variables - graded assignments int currentAssignments = 5;int sophia1 = 93;int sophia2 = 87;int sophia3 = 98;int sophia4 = 95;int sophia5 = 100;int nicolas1 = 80;int nicolas2 = 83;int nicolas3 = 82;int nicolas4 = 88;int nicolas5 = 85;int zahirah1 = 84;int zahirah2 = 96;int zahirah3 = 73;int zahirah4 = 85;int zahirah5 = 79;int jeong1 = 90;int jeong2 = 92;int jeong3 = 98;int jeong4 = 100;int jeong5 = 97;int sophiaSum = sophia1 + sophia2 + sophia3 + sophia4 + sophia5;int nicolasSum = nicolas1 + nicolas2 + nicolas3 + nicolas4 + nicolas5;int zahirahSum = zahirah1 + zahirah2 + zahirah3 + zahirah4 + zahirah5;int jeongSum = jeong1 + jeong2 + jeong3 + jeong4 + jeong5;decimal sophiaScore = (decimal) sophiaSum / currentAssignments;decimal nicolasScore = (decimal) nicolasSum / currentAssignments;decimal zahirahScore = (decimal) zahirahSum / currentAssignments;decimal jeongScore = (decimal) jeongSum / currentAssignments;Console.WriteLine(&quot;Student\\t\\tGrade\\n&quot;);Console.WriteLine(&quot;Sophia:\\t\\t&quot; + sophiaScore + &quot;\\tA&quot;);Console.WriteLine(&quot;Nicolas:\\t&quot; + nicolasScore + &quot;\\tB&quot;);Console.WriteLine(&quot;Zahirah:\\t&quot; + zahirahScore + &quot;\\tB&quot;);Console.WriteLine(&quot;Jeong:\\t\\t&quot; + jeongScore + &quot;\\tA&quot;); 重點整理這篇意外的沒什麼重點，大概就是前面四個章節大統整後的練習這樣。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231004/csharp-freecodecamp-challenge-05/"},{"title":"C# Challenge 06 - 引導式專案 - 計算最終 GPA","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第六單元章節的內容。 本節內容計算出某位學生的 GPA 結果，並按照指引一部一部完成數字和字串的處理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051string studentName = &quot;Sophia Johnson&quot;;string course1Name = &quot;English 101&quot;;string course2Name = &quot;Algebra 101&quot;;string course3Name = &quot;Biology 101&quot;;string course4Name = &quot;Computer Science I&quot;;string course5Name = &quot;Psychology 101&quot;;int course1Credit = 3;int course2Credit = 3;int course3Credit = 4;int course4Credit = 4;int course5Credit = 3;int gradeA = 4;int gradeB = 3;int course1Grade = gradeA;int course2Grade = gradeB;int course3Grade = gradeB;int course4Grade = gradeB;int course5Grade = gradeA;int totalCreditHours = 0;totalCreditHours += course1Credit;totalCreditHours += course2Credit;totalCreditHours += course3Credit;totalCreditHours += course4Credit;totalCreditHours += course5Credit;int totalGradePoints = 0;totalGradePoints += course1Credit * course1Grade;totalGradePoints += course2Credit * course2Grade;totalGradePoints += course3Credit * course3Grade;totalGradePoints += course4Credit * course4Grade;totalGradePoints += course5Credit * course5Grade;decimal gradePointAverage = (decimal) totalGradePoints/totalCreditHours;int leadingDigit = (int) gradePointAverage;int trailingDigits = (int) (gradePointAverage * 100) - (leadingDigit * 100);Console.WriteLine($&quot;Student: {studentName}\\n&quot;);Console.WriteLine(&quot;Course\\t\\t\\t\\tGrade\\tCredit Hours&quot;);Console.WriteLine($&quot;{course1Name}\\t\\t\\t{course1Grade}\\t\\t{course1Credit}&quot;);Console.WriteLine($&quot;{course2Name}\\t\\t\\t{course2Grade}\\t\\t{course2Credit}&quot;);Console.WriteLine($&quot;{course3Name}\\t\\t\\t{course3Grade}\\t\\t{course3Credit}&quot;);Console.WriteLine($&quot;{course4Name}\\t{course4Grade}\\t\\t{course4Credit}&quot;);Console.WriteLine($&quot;{course5Name}\\t\\t{course5Grade}\\t\\t{course5Credit}&quot;);Console.WriteLine($&quot;\\nFinal GPA:\\t\\t\\t{leadingDigit}.{trailingDigits}&quot;); 重點整理這也是延續上一個章節到內容，持續的做字串和數字的處理。利用運算符和字串的組合來完成題目的要求，然後針對 decimal 和 int 型別更加多的理解與學習。 知識點的部分有： 假設 decimal gradePointAverage = 3.99872831;。(int) gradePointAverage的值為何？ Ans : 3 在下列程式碼 decimal x = 7 / 5; 中，為什麼 x = 1？ Ans : 分割兩個整數會執行整數除法 那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231006/csharp-freecodecamp-challenge-06/"},{"title":"C# Challenge 07 - 安裝及設定 Visual Studio Code","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第七單元章節的內容。 本節內容安裝 .NET SDK到微軟的頁面去下載，載完之後打開電腦的終端機（ Windows 的是 命令提示字元 ， Mac 系列的話是終端機或是自己下載的 iTerm 皆可 ）並輸入以下指令： 1dotnet --version 如果已經安裝某一版本的 .NET 的話，應該會看到列出類似下列的版本號碼： 17.0.306 如果沒有出現的話代表沒有成功安裝，有的話就代表成功了。且第一個數字代表的是 .NET 的版本號，所以我現在有成功安裝了 .NET 7 SDK 。 編輯第一個 .NET 專案建立一個 .NET 專案 1dotnet new console -o ./CsharpProjects/TestProject 編譯 .NET 的檔案 1dotnet build 執行 .NET 的檔案 1dotnet run 重點整理教你怎麼下載 Visual Studio Code 還有安裝 .NET SDK ，身為工程師這些東西應該早就要裝好了吧！所以這邊也算是沒什麼知識點的一篇，希望下一章節開始可以繼續學 C# 的新東西。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231006/csharp-freecodecamp-challenge-07/"},{"title":"C# Challenge 08 - 使用 C# 從 .NET Class Library 呼叫方法","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第八單元章節的內容。 本節內容什麼是 .NET Class Library？ .NET Class Library 是一個數以千計類別的集合，當中包含數以萬計的方法。 像是常用的 Console 類別裡面包含了 Write() 和 WriteLine() 等方法，另外要特別注意的地方是， 資料型別 也是屬於 .NET Class Library 的範疇之一。 有狀態和無狀態方法 在軟體發展專案中，狀態 ( State ) 一詞是用來描述執行環境在特定時間點的條件。 以下共分為兩種 無狀態方法： 又稱為靜態方法 ，指的是該方法能夠在不需要參考或是變更儲存在記憶體中任何值的情況下操作。 有狀態方法： 又稱為執行個體方法 ，指的是其必須仰賴由自己執行的前幾行程式碼儲存在記憶體中的值。 特別注意：單一類別 ( Class ) 可以同時支援具狀態與無狀態方法。 不過，當您需要呼叫有狀態方法時，您必須先建立類別的執行個體，來使該方法可以存取狀態。 建立新的類別執行個體 - 物件 1Random dice = new Random(); 這裡使用到的是 new 運算子，它的執行工作為： 會先要求電腦記憶體中的位址，該位址必須大到可以儲存以 Random 類別為基礎的新物件。 會建立新物件，並將其儲存在該記憶體位址。 會傳回記憶體位址，以將其儲存在 dice 變數中。 Void 方法不會在方法跑完時回傳任何的值，稱為 Void 方法。 參數的概念 通常，’parameter’ 和 ‘argument’ 字詞會交替使用。 不過，’parameter’ 是指在方法內使用的變數。 ‘argument’ 是呼叫方法時傳遞的值。 多載 多載 ( Overload ) 就是指一個類別具有相同名稱但不同參數的函式。 Math.Max() 12345int firstValue = 500;int secondValue = 600;int largerValue;largerValue = Math.Max(firstValue, secondValue);Console.WriteLine(largerValue); Math.Max() 方法支援 13 個多載版本以接受不同的資料類型。 呼叫 Math.Max() 方法的多載版本將接受 int 作為這兩個輸入參數，並以 int 的形式傳回這兩個值中較大的值。 重點整理今天一樣都是基礎的概念，不過有開始提到在 function 中傳遞參數時要加上型別，還有 C# 的 void 方法都是之前 JS 內沒有遇過的。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231010/csharp-freecodecamp-challenge-08/"},{"title":"C# Challenge 09 - 使用 C# 中的 &#39;if&#39;、&#39;else&#39; 和 &#39;else if&#39; 陳述式將決策邏輯新增至程式碼","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第九單元章節的內容。 本節內容if 陳述式if 陳述式依賴用一組括弧括住的布林運算式。 如果運算式為 True，則會執行陳述式 if 之後的程式碼。 如果不是，NET 執行階段會忽略該程式碼，而且不會執行。 布林運算式 布林運算式是任何會傳回布林值 (true 或 false) 的程式碼。 最簡單的布林運算式就只是值 true 與 false。 或者，布林運算式可以是傳回值 true 或 false 的方法結果。 該運算式可以使用其他的運算子來比較計算的值，其中包括： == ，用來測試是否相等的「等於」運算子 &gt; ，用來測試左邊值是否大於右邊值的「大於」運算子 &lt; ，用來測試左邊值是否小於右邊值的「小於」運算子 &gt;= ，「大於或等於」運算子 &lt;=，「小於或等於」運算子 擲骰題目練習 12345678910111213141516171819202122232425262728293031323334353637383940Random dice = new Random();int roll1 = dice.Next(1, 7);int roll2 = dice.Next(1, 7);int roll3 = dice.Next(1, 7);int total = roll1 + roll2 + roll3;Console.WriteLine($&quot;Dice roll: {roll1} + {roll2} + {roll3} = {total}&quot;);if ((roll1 == roll2) || (roll2 == roll3) || (roll1 == roll3)){ if ((roll1 == roll2) &amp;&amp; (roll2 == roll3)) { Console.WriteLine(&quot;You rolled triples! +6 bonus to total!&quot;); total += 6; } else { Console.WriteLine(&quot;You rolled doubles! +2 bonus to total!&quot;); total += 2; }}if (total &gt;= 16){ Console.WriteLine(&quot;You win a new car!&quot;);}else if (total &gt;= 10){ Console.WriteLine(&quot;You win a new laptop!&quot;);}else if (total == 7){ Console.WriteLine(&quot;You win a trip for two!&quot;);}else{ Console.WriteLine(&quot;You win a kitten!&quot;);} 訂閱制範例練習 1234567891011121314151617181920212223Random random = new Random();int daysUntilExpiration = random.Next(12);int discountPercentage = 0;if( daysUntilExpiration &lt;=10 ) { if ( daysUntilExpiration == 0){ Console.WriteLine(&quot;Your subscription has expired.&quot;); } else if ( daysUntilExpiration &lt;= 1 ){ Console.WriteLine(&quot;Your subscription expires within a day!&quot;); discountPercentage = 20; } else if (daysUntilExpiration &lt;= 5 ){ Console.WriteLine($&quot;Your subscription expires in {daysUntilExpiration} days.&quot;); discountPercentage = 10; }};if(discountPercentage &gt; 0){ Console.WriteLine($&quot;Renew now and save {discountPercentage}%.&quot;);}; 重點整理透過大量的範例讓大家練習 if… else 的判斷，官方的寫法比較簡單暴力一點，我最後選擇使用自己的寫法記錄在這邊。感覺好像什麼大考前的複習，一直在看很多基礎的東西哈哈。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231011/csharp-freecodecamp-challenge-09/"},{"title":"C# Challenge 10 - 使用 C# 中的陣列及 foreach 陳述式來儲存及逐一查看資料序列","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第十單元章節的內容。 陣列 陣列是特殊類型的變數，可保存相同資料類型的多個值。 宣告語法稍有不同，因為您必須同時指定資料類型和陣列大小。 foreach 詐騙訂單 123456789101112131415string name = &quot;Bob&quot;;if (name.StartsWith(&quot;B&quot;)){ Console.WriteLine(&quot;The name starts with 'B'!&quot;);}string[] orderIDs = { &quot;B123&quot;, &quot;C234&quot;, &quot;A345&quot;, &quot;C15&quot;, &quot;B177&quot;, &quot;G3003&quot;, &quot;C235&quot;, &quot;B179&quot; };foreach (string orderID in orderIDs){ if (orderID.StartsWith(&quot;B&quot;)) { Console.WriteLine(orderID); }} 重點整理教你怎麼用 foreach ，要記得是 想要的屬性 in 陣列 喔那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231012/csharp-freecodecamp-challenge-10/"},{"title":"Design Pattern 設計模式系列文開張","text":"踏入軟體開發的世界後，一定早晚都會接觸到的 Design Pattern 總算來了。接下來的系列文章除了跟大家介紹設計模式是什麼之外也會說明其中的 23 種不同的模式究竟有哪些？那就一起來看看吧！ 什麼是設計模式？ Design Pattern 設計模式是在軟體開發中的一種針對常見的開發問題所提出的一套解決方案。 設計模式的基礎概念根據上面簡易的描述，我們可以知道設計模式的出現和存在除了要解決那些會重複出現的軟體開發問題有一個可以遵照的解決辦法之外，其實這些設計原則還能夠讓我們開發的專案或是產品更有規劃也可以讓之後要開發的新功能可以遵照一定的設計模式與專案做結合。 所以我們在網路上查到的很多資料也都有特別點出設計模式為什麼會在軟體開發界被廣泛地使用，原因就是在這些上面。因此你也有可能曾經在開發的時候就使用過相關的設計模式的規則，只是你自己不知道原來那也是設計模式的範疇中喔！ 對設計模式的個人見解目前的工程師職涯經驗中，通常公司或是產品到達一定規模的時候就會接觸到設計模式的概念了。原因也很簡單，因為越大規模的產品隨之而來的就是開發團隊人數的成長，因此在人數較多的開發團隊中使用有清楚規範撰寫風格和功能的設計模式對團隊已經公司來說絕對是很加分的。 另外想特別補充，我個人覺得在有導入設計模式的產品中會相對比較少出現不必要的程式碼或是重複的 function 和 功能，這個對專案的維護真的有很大的幫助！還有針對剛接觸公司產品的開發人員（不管是新進人員或是其他部門的開發同仁）都能更快的進入開發中的準備，因為設計模式在各地都是通用的，因此只要遵照這樣的模式即便產品還尚未熟悉，但是還是可以從中找出一些這個產品或是專案的撰寫習慣和規範。 接下來要介紹的設計模式有哪些？接下來會陸續來介紹 GoF ( Gang of Four ) 所提出的 23 種設計模式，以下先跟大家大致說明有哪 23 個設計模式？ Creational PatternsCreational 的類別就是處理關於創造一個新物件時，可以參考的相關設計模式。總共有以下 5 種： Singleton Factory Abstract Factory Builder Prototype Structural PatternsStructural 這大類主要是處理 class 相關的結構問題，例如：繼承 Inheritance 和組合 Composition Adapter Composite Proxy Flyweight Facade Bridge Decorator Behavioral PatternsBehavioral 這個類別就會針對不同物件之間該怎麼溝通和共用，還有注重在怎麼降低功能或是物件之間的耦合以及針對專案未來開發的新功能的便利性和彈性等。 Template Method Mediator Chain of Responsibility Observer Strategy Command State Visitor Interpreter Iterator Memento 結語今天先大概和大家簡述了設計模式 Design Pattern 究竟是什麼之外，也整理出接下來要向大家介紹的 23 種設計模式並分門別類列出來。期待接下來能跟著大家一起站在前人的肩膀上來研究這些偉大的設計模式～那我們下次見ʘ‿ʘ 參考資料 設計模式(Design Patterns) Gangs of Four (GoF) Design Patterns","link":"/20231126/design-pattern-guide-introduction/"},{"title":"C# Challenge 11 - 使用 C# 中的慣例、空白字元與註解，建立可讀取的程式碼","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第 11 單元的內容。 本節內容常見的變數命名規範 駝峰式命名 string thisIsCamelCase; 絕對不要簡寫，因為除了你自己以外的人會看不懂 好的範例： 1234567char userOption;int gameScore;float particlesPerMillion;bool processedCustomer; 怎麼在編輯器中註解第一種單行的註解 // 12345678910111213141516171819Random random = new Random();string[] orderIDs = new string[5];// Loop through each blank orderIDfor (int i = 0; i &lt; orderIDs.Length; i++){ // Get a random value that equates to ASCII letters A through E int prefixValue = random.Next(65, 70); // Convert the random value into a char, then a string string prefix = Convert.ToChar(prefixValue).ToString(); // Create a random number, pad with zeroes string suffix = random.Next(1, 1000).ToString(&quot;000&quot;); // Combine the prefix and suffix together, then assign to current OrderID orderIDs[i] = prefix + suffix;}// Print out each orderIDforeach (var orderID in orderIDs){ Console.WriteLine(orderID);} 第二種多行的註解 /* */ 12345/*string firstName = &quot;Bob&quot;;int widgetsPurchased = 7;Console.WriteLine($&quot;{firstName} purchased {widgetsPurchased} widgets.&quot;);*/ 空白字元適度的留空白行比較方便開發人員去做編輯和修改ㄛ！ 重點整理這個章節算是開發習慣的一個大方向建議，裡面有特別提到關於註解的部分也不要完全相信，因為有時候邏輯或是內容有替換但是忘記修改就會發生認知錯誤，所以記得還是要自己去釐清一下該功能的邏輯後再去做新的開發或者是維護。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231016/csharp-freecodecamp-challenge-11/"},{"title":"C# Challenge 12 - 引導式專案 - 開發 Foreach 和 if-elseif-else 結構，以在 C# 中處理陣列資料","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第 12 單元的內容。 本節內容學生評分應用程式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// initialize variables - graded assignmentsint examAssignments = 5;int[] sophiaScores = new int[] { 90, 86, 87, 98, 100, 94, 90 };int[] andrewScores = new int[] { 92, 89, 81, 96, 90, 89 };int[] emmaScores = new int[] { 90, 85, 87, 98, 68, 89, 89, 89 };int[] loganScores = new int[] { 90, 95, 87, 88, 96, 96 };// Student namesstring[] studentNames = new string[] { &quot;Sophia&quot;, &quot;Andrew&quot;, &quot;Emma&quot;, &quot;Logan&quot; };int[] studentScores = new int[10];string currentStudentLetterGrade = &quot;&quot;;// Write the Report Header to the consoleConsole.WriteLine(&quot;Student\\t\\tGrade\\n&quot;);foreach (string name in studentNames){ string currentStudent = name; if (currentStudent == &quot;Sophia&quot;) studentScores = sophiaScores; else if (currentStudent == &quot;Andrew&quot;) studentScores = andrewScores; else if (currentStudent == &quot;Emma&quot;) studentScores = emmaScores; else if (currentStudent == &quot;Logan&quot;) studentScores = loganScores; // initialize/reset the sum of scored assignments int sumAssignmentScores = 0; // initialize/reset the calculated average of exam + extra credit scores decimal currentStudentGrade = 0; // initialize/reset a counter for the number of assignment int gradedAssignments = 0; // loop through the scores array and complete calculations for currentStudent foreach (int score in studentScores) { // increment the assignment counter gradedAssignments += 1; if (gradedAssignments &lt;= examAssignments) // add the exam score to the sum sumAssignmentScores += score; else // add the extra credit points to the sum - bonus points equal to 10% of an exam score sumAssignmentScores += score / 10; } currentStudentGrade = (decimal)(sumAssignmentScores) / examAssignments; if (currentStudentGrade &gt;= 97) currentStudentLetterGrade = &quot;A+&quot;; else if (currentStudentGrade &gt;= 93) currentStudentLetterGrade = &quot;A&quot;; else if (currentStudentGrade &gt;= 90) currentStudentLetterGrade = &quot;A-&quot;; else if (currentStudentGrade &gt;= 87) currentStudentLetterGrade = &quot;B+&quot;; else if (currentStudentGrade &gt;= 83) currentStudentLetterGrade = &quot;B&quot;; else if (currentStudentGrade &gt;= 80) currentStudentLetterGrade = &quot;B-&quot;; else if (currentStudentGrade &gt;= 77) currentStudentLetterGrade = &quot;C+&quot;; else if (currentStudentGrade &gt;= 73) currentStudentLetterGrade = &quot;C&quot;; else if (currentStudentGrade &gt;= 70) currentStudentLetterGrade = &quot;C-&quot;; else if (currentStudentGrade &gt;= 67) currentStudentLetterGrade = &quot;D+&quot;; else if (currentStudentGrade &gt;= 63) currentStudentLetterGrade = &quot;D&quot;; else if (currentStudentGrade &gt;= 60) currentStudentLetterGrade = &quot;D-&quot;; else currentStudentLetterGrade = &quot;F&quot;; //Console.WriteLine(&quot;Student\\t\\tGrade\\tLetter Grade\\n&quot;); Console.WriteLine($&quot;{currentStudent}\\t\\t{currentStudentGrade}\\t{currentStudentLetterGrade}&quot;);}// required for running in VS Code (keeps the Output windows open to view results)Console.WriteLine(&quot;\\n\\rPress the Enter key to continue&quot;);Console.ReadLine(); 重點整理也是一個 foreach 的練習專案，內容大同小異不過有結合上一單元的一些知識，一樣直接把答案貼上來給大家參考。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231017/csharp-freecodecamp-challenge-12/"},{"title":"C# Challenge 13 - 挑戰專案 - 開發 Foreach 和 if-elseif-else 結構，以在 C# 中處理陣列資料","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第 13 單元的內容。 本節內容延續上一單元的練習，不過這邊偷懶沒有做完，之後再補上。 重點整理一樣使用 foreach 來做學生分數計算的練習，所以等於二次練習囉！那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231018/csharp-freecodecamp-challenge-13/"},{"title":"C# Challenge 14 - 在 C# 中評估布林運算式以進行決策","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第 14 單元的內容。 本節內容常見的運算子 有許多不同種類的運算式會評估為 true 或 false。 使用 == 運算子評估相等。 評估字串是否相等時，必須考慮字串可能大小寫不同及有前後空格。 視您的情況而定，使用 ToLower() 或 ToUpper() 協助程式方法及 Trim() 協助程式方法，以改善兩個字串相等的可能性。 使用 != 運算子來評估不等。 使用 &gt;、&lt;、&gt;= 與 &lt;= 等比較運算子，評估大於、小於與類似的作業。 如果方法傳回布林值，則它可以作為布林運算式使用。 使用邏輯否定運算子 ! 來評估指定運算式的相反。 條件運算子寫法： 1&lt;evaluate this condition&gt; ? &lt;if condition is true, return this value&gt; : &lt;if condition is false, return this value&gt; 範例： 123int saleAmount = 1001;int discount = saleAmount &gt; 1000 ? 100 : 50;Console.WriteLine($&quot;Discount: {discount}&quot;); 重點整理教你怎麼用一般的運算子，還有實務開發上比較常用到的條件運算子。這部分跟 JS 也是一樣的那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231019/csharp-freecodecamp-challenge-14/"},{"title":"Vim 同時操作多行或多個相同單字的方法","text":"記錄一下用 Vim 怎麼選取並同時編輯多行？還有怎麼選取多個相同單字並修改？因為懶得輸入太長的指令，喜歡按多個組合鍵 combo ，所以以下的方法大家可以參考就看看就好喔！ 情境整理一次選取並編輯多行內容 先在 Normal Mode 中選取要編輯的多行，這邊我使用的是 V 加上 j 往下跳到欲選取的最後一行。 選取完畢之後，使用 A 或是 I 後就可以編輯了。 同時選取並編輯多個相同單字 先在 Normal Mode 中選取該單字，我使用的是 viw 選取游標停留位置上的單字。 使用 command + d 的方式選取多個相同的單字。 最後使用 A 或是 I 後就可以編輯了。 筆記心得感覺這些都是蠻常會出現的開發情境，只是因為語法還不熟所以一直會偷懶用笨方法。現在強迫自己邊學邊用邊紀錄，這樣會許可以越來越加快上手。但有時候會覺得，人們花了蠻多心力去發明出滑鼠，結果開發人員卻想返璞歸真，挺有趣ㄉ！那我們下次見ʘ‿ʘ 參考資料 Vim 高級技巧 Vim下多行同时编辑与删除技巧 Know your VIM - 基本文字選取篇","link":"/20231019/vim-command-useful-note-multipleselect/"},{"title":"C# Challenge 15 - 在 C# 中使用程式碼區塊控制變數範圍和邏輯","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第 15 單元的內容。 本節內容作用域的概念介紹關於撰寫變數時，變數的作用域概念以及為何在作用域以外取不到值。 將 if 的大括號移除後的影響 如果您意識到 if-elseif-else 陳述式的程式碼區塊中只列出一行程式碼，您可以移除程式碼區塊的大括弧和空白字元。 Microsoft 建議將大括弧一致地用於 if-elseif-else 陳述式的所有程式碼區塊 (存在或一致移除)。 只有在程式碼區塊讓程式碼更容易閱讀時，才移除大括弧。 一律可以接受包含大括弧。 移除換行字元的唯一目的，是要讓程式碼更容易閱讀。 Microsoft 建議當每個陳述式放在自己的程式程式碼時，您的程式碼將會更容易閱讀。 重點整理可以把大括號移除的 if 陳述式有點驚人，只是說就像官方教程說的：閱讀性奇差無比！那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231020/csharp-freecodecamp-challenge-15/"},{"title":"C# Challenge 16 - 使用 C# 中的 switch-case 建構建立程式碼流程分支","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第 16 單元的內容。 本節內容switch 陳述式switch 功能與寫法 都不符合才會進入到 default ，不論 default 是不是放在最後一個 除非遇到 break ，不然會繼續比對下一個條件(return, throw 等也會直接離開 switch 區塊) 12345678910111213141516171819202122232425int employeeLevel = 200;string employeeName = &quot;John Smith&quot;;string title = &quot;&quot;;switch (employeeLevel){ case 100: title = &quot;Junior Associate&quot;; break; case 200: title = &quot;Senior Associate&quot;; break; case 300: title = &quot;Manager&quot;; break; case 400: title = &quot;Senior Manager&quot;; break; default: title = &quot;Associate&quot;; break;}Console.WriteLine($&quot;{employeeName}, {title}&quot;); 注意：選擇性 default 標籤可以出現在 switch 區段清單中的任何位置。 不過，大部分開發人員都會選擇將其放在最後一個位置，因為將 default 放在最後的選項更為合理 (邏輯上)。 不論位置為何，都會最後評估 default 區段。 多個 case 符合的狀況可以將統一結果的條件寫在一起，如下面範例所示： 1234case 100:case 200: title = &quot;Senior Associate&quot;; break; switch 語法練習問題123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// SKU = Stock Keeping Unit. // SKU value format: &lt;product #&gt;-&lt;2-letter color code&gt;-&lt;size code&gt;string sku = &quot;01-MN-L&quot;;string[] product = sku.Split('-');string type = &quot;&quot;;string color = &quot;&quot;;string size = &quot;&quot;;if (product[0] == &quot;01&quot;){ type = &quot;Sweat shirt&quot;;} else if (product[0] == &quot;02&quot;){ type = &quot;T-Shirt&quot;;} else if (product[0] == &quot;03&quot;){ type = &quot;Sweat pants&quot;;}else{ type = &quot;Other&quot;;}if (product[1] == &quot;BL&quot;){ color = &quot;Black&quot;;} else if (product[1] == &quot;MN&quot;){ color = &quot;Maroon&quot;;} else{ color = &quot;White&quot;;}if (product[2] == &quot;S&quot;){ size = &quot;Small&quot;;} else if (product[2] == &quot;M&quot;){ size = &quot;Medium&quot;;} else if (product[2] == &quot;L&quot;){ size = &quot;Large&quot;;} else{ size = &quot;One Size Fits All&quot;;}Console.WriteLine($&quot;Product: {size} {color} {type}&quot;); 解答12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// SKU = Stock Keeping Unitstring sku = &quot;01-MN-L&quot;;string[] product = sku.Split('-');string type = &quot;&quot;;string color = &quot;&quot;;string size = &quot;&quot;;switch (product[0]){ case &quot;01&quot;: type = &quot;Sweat shirt&quot;; break; case &quot;02&quot;: type = &quot;T-Shirt&quot;; break; case &quot;03&quot;: type = &quot;Sweat pants&quot;; break; default: type = &quot;Other&quot;; break;}switch (product[1]){ case &quot;BL&quot;: color = &quot;Black&quot;; break; case &quot;MN&quot;: color = &quot;Maroon&quot;; break; default: color = &quot;White&quot;; break;}switch (product[2]){ case &quot;S&quot;: size = &quot;Small&quot;; break; case &quot;M&quot;: size = &quot;Medium&quot;; break; case &quot;L&quot;: size = &quot;Large&quot;; break; default: size = &quot;One Size Fits All&quot;; break;}Console.WriteLine($&quot;Product: {size} {color} {type}&quot;); 重點整理這個章節主要是讓大家練習如何使用 switch 的功能，相較於 if...else 的陳述式，在更多不同的條件下會大幅的提升可讀性。有透過實際需求練習真的是還不錯，可以更知道兩者之間應該要如何轉換？那我們下次見ʘ‿ʘ 參考資料 C# switch 基礎和進階使用方式示範 C# Certification with freeCodeCamp Challenge","link":"/20231023/csharp-freecodecamp-challenge-16/"},{"title":"C# Challenge 17 - 使用 C# 的 for 陳述式逐一查看程式碼區塊","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第 17 單元的內容。 本節內容for 迴圈什麼是 for 迴圈？可以重複執行某一段程式碼邏輯的功能，主要應用的場景會發生在已知要重複執行次數的情境之下。 1234for (int i = 0; i &lt; 10; i++){ Console.WriteLine(i);} 使用 break 關鍵字來中斷 for 迴圈我們也可以在 for 迴圈中設定當符合特定條件時，結束 function 的重複執行並離開該迴圈。 12345for (int i = 0; i &lt; 10; i++){ Console.WriteLine(i); if (i == 7) break;} for 迴圈使用重點 for 反覆運算陳述式可讓您逐一查看程式碼區塊達特定次數。 for 反覆運算陳述式可讓您藉由改變括弧內下列三個條件來控制反覆運算機制的每個層面：初始設定式、條件和迭代器。 當您需要控制想要如何逐一查看陣列中的每個項目時，通常會使用 for 陳述式。 如果您的程式碼區塊只有一行程式碼，您可以視需要清除大括號和空白字元。 挑戰練習 - FizzBuzz12345678910111213141516171819for (int i = 1; i &lt;= 100; i++){ if (i % 3 == 0 &amp;&amp; i % 5 == 0) { Console.WriteLine($&quot;{i} - FizzBuzz&quot;); } else if (i % 3 == 0) { Console.WriteLine($&quot;{i} - Fizz&quot;); } else if (i % 5 == 0) { Console.WriteLine($&quot;{i} - Buzz&quot;); } else { Console.WriteLine(i); }} 重點整理練習 for 迴圈搭配條件判斷式，算是實務上蠻常使用到的功能類型，也是面試的熱門考題之一。建議大家除了官方提供的解答之外，也可以試著自己想其他的解法或是用 ChatGPT 來想一下可以做題目的方想有哪些喔～那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge C#學習筆記－(4)流程控制－迴圈：for loop &amp; while loop","link":"/20231023/csharp-freecodecamp-challenge-17/"},{"title":"C# Challenge 18 - 在 C# 中使用 do-while 和 while 陳述式將迴圈邏輯新增至您的程式碼","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第 18 單元的內容。 本節內容do-while 陳述式什麼是 do-while 陳述式只要指定的布林運算式裡面的值為 true 時，就會持續執行 do 函式內的功能或處理。 1234do{ // This code executes at least one time} while (true) do-while 的使用重點 do-while 陳述式會逐一查看程式碼區塊至少一次，並可能會根據布林運算式繼續逐一查看。 布林運算式評估通常取決於程式碼區塊內部產生或擷取的某些值。 while 陳述式會先評估布林運算式，並在布林運算式評估為 true 時繼續逐一查看程式碼區塊。 continue 關鍵字會立即進入布林運算式。 重點整理感覺後面的章節越來越多實作的內容，知識點的檢驗也越來越以實際開發的專案情節來做說明跟測試，蠻貼近真正的開發情境！那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231023/csharp-freecodecamp-challenge-18/"},{"title":"C# Challenge 19 - 引導式專案 - 在 C# 中開發條件式分支和迴圈結構","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第 19 單元的內容。 本節內容Contoso Pets 專案變數宣告123456789101112131415// the ourAnimals array will store the following: string animalSpecies = &quot;&quot;;string animalID = &quot;&quot;;string animalAge = &quot;&quot;;string animalPhysicalDescription = &quot;&quot;;string animalPersonalityDescription = &quot;&quot;;string animalNickname = &quot;&quot;;// variables that support data entryint maxPets = 8;string? readResult;string menuSelection = &quot;&quot;;// array used to store runtime data, there is no persisted datastring[,] ourAnimals = new string[maxPets, 6]; 為 switch 陳述式保留條件撰寫的位置123456789101112131415switch (menuSelection){ case &quot;1&quot;: // List all of our current pet information Console.WriteLine(&quot;this app feature is coming soon - please check back to see progress.&quot;); Console.WriteLine(&quot;Press the Enter key to continue.&quot;); readResult = Console.ReadLine(); break; case &quot;2&quot;: // List all of our current pet information Console.WriteLine(&quot;this app feature is coming soon - please check back to see progress.&quot;); Console.WriteLine(&quot;Press the Enter key to continue.&quot;); readResult = Console.ReadLine(); break; 重點整理跟之前一樣的引導式專案，沒有特別記錄什麼重點，就是按照他的指引一步一步完成這個專案內容。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231023/csharp-freecodecamp-challenge-19/"},{"title":"C# Challenge 21 - 在您的 C# 程式碼中選擇正確資料類型","text":"Microsoft 2023 年所提供的 C# codecamp 基礎課程，總共有 38 個單元，完成後就可以獲得 Certification ，今天要來跟大家分享的是第 21 單元的內容。 由於上一個單元也是類似於挑戰專案，所以我就直接略過第 20 單元的內容往下一個章節來記錄。 本節內容實質型別和參考型別 實值型別會以位元儲存，而位元即是簡易的開啟/關閉切換。 合併足夠數量的這些切換，便可讓您儲存幾乎任何可能的值。 有兩種資料類型的基本分類：實值和參考型別。 其差異在於當您的程式正在執行時，電腦儲存值的方式和位置。 簡單實值型別會使用關鍵字別名來表示 .NET 程式庫中類型的正式名稱。 各種資料類型的值的範圍Input: 1234567891011121314Console.WriteLine(&quot;Signed integral types (帶正負號):&quot;);Console.WriteLine($&quot;sbyte : {sbyte.MinValue} to {sbyte.MaxValue}&quot;);Console.WriteLine($&quot;short : {short.MinValue} to {short.MaxValue}&quot;);Console.WriteLine($&quot;int : {int.MinValue} to {int.MaxValue}&quot;);Console.WriteLine($&quot;long : {long.MinValue} to {long.MaxValue}&quot;);Console.WriteLine(&quot;&quot;);Console.WriteLine(&quot;Unsigned integral types (不帶正負號) :&quot;);Console.WriteLine($&quot;byte : {byte.MinValue} to {byte.MaxValue}&quot;);Console.WriteLine($&quot;ushort : {ushort.MinValue} to {ushort.MaxValue}&quot;);Console.WriteLine($&quot;uint : {uint.MinValue} to {uint.MaxValue}&quot;);Console.WriteLine($&quot;ulong : {ulong.MinValue} to {ulong.MaxValue}&quot;); Output: 1234567891011Signed integral types(帶正負號):sbyte : -128 to 127short : -32768 to 32767int : -2147483648 to 2147483647long : -9223372036854775808 to 9223372036854775807Unsigned integral types(不帶正負號):byte : 0 to 255ushort : 0 to 65535uint : 0 to 4294967295ulong : 0 to 18446744073709551615 浮點數型別範圍比較Input: 12345Console.WriteLine(&quot;&quot;);Console.WriteLine(&quot;Floating point types:&quot;);Console.WriteLine($&quot;float : {float.MinValue} to {float.MaxValue} (with ~6-9 digits of precision)&quot;);Console.WriteLine($&quot;double : {double.MinValue} to {double.MaxValue} (with ~15-17 digits of precision)&quot;);Console.WriteLine($&quot;decimal: {decimal.MinValue} to {decimal.MaxValue} (with 28-29 digits of precision)&quot;); Output: 1234Floating point types:float : -3.402823E+38 to 3.402823E+38 (with ~6-9 digits of precision)double : -1.79769313486232E+308 to 1.79769313486232E+308 (with ~15-17 digits of precision)decimal: -79228162514264337593543950335 to 79228162514264337593543950335 (with 28-29 digits of precision) 重點分析 浮點數類型是簡易的數值資料類型，可保存小數。 當為應用程式選擇正確浮點數類型時，要考慮的不只是其可保存的最大和最小值。 您也必須考慮在十進位之後能保存多少值、儲存數字的方式，以及其內部儲存裝置會對數學運算結果產生何種影響。 浮點數值在數字成長到相當龐大時，有時候可使用「E 標記法」來表示。 編譯器和執行階段處理 decimal 的方式，與處理 float 或 double 的方式有基本差異，尤其是在判斷數學運算所需的正確性程度時。 資料型別大致參照規則 int 用於大多數的整數 decimal 用於表示貨幣的數字 bool 用於 True 或 False 值 string 用於英數值 重點整理這邊我覺得比較重要的是 float 以及 decimal 的區別，下面是請 ChatGPT 幫我整理的判斷情境： 如果需要高精確度的計算，特別是在金融或貨幣領域，則應使用 decimal。 如果處理的是大量數據，並且可以容忍一些精確度損失，則 float 可能更適合，因為它在計算速度方面更高效。 通常情況下，對於一般科學計算，double（雙精度浮點數，64位元）是一個較好的選擇，因為它提供了合理的精確度和性能。 所以根據上述的情境我們可以比較了解在撰寫 function 時應該選擇哪一些資料型別，幫助釐清開發需求和制定規範。那我們下次見ʘ‿ʘ 參考資料 C# Certification with freeCodeCamp Challenge","link":"/20231023/csharp-freecodecamp-challenge-21/"},{"title":"如何離開 Vim 的環境？三種不同的方法記錄","text":"這幾天在公司建立開發環境時也使用到了 vim 的指令來調整 host 的網址，於是終於在這樣的機會下知道有三種不同離開 vim 環境的方式和功能。如果你剛好有需要找到這篇文章的話，繼續往下看吧！ 離開的方法不管是不小心進入 vim 的編輯模式或是在編輯完相關內容後要離開等等的情境，都有不同的指令可以滿足你的需求喔！ 記得在 vim 的環境中要切換成英文輸入法，才能讓指令正常作用。 沒有編輯任何內容後要離開可以輸入 :q （包含冒號），就可以離開 vim 的環境 有編輯過檔案或是設定的內容後，需要保存變更後離開輸入 :wq （包含冒號），就可以儲存剛才編輯的內容後離開 vim 的環境 雖然編輯過檔案，但是想要放棄編輯不儲存輸入 :q! （包含冒號），就可以放棄剛才編輯的內容後離開 vim 的環境 筆記心得以前都只會用 :wq 原本以為這樣就足夠了，但確實有時候不小心把一些設定檔寫壞想要放棄剛剛編輯過的紀錄的時候，就非常適合使用 :q! 喔！希望這篇有幫助到正卡在 vim 的編輯器中怎麼樣的出不來的你，那我們下次見ʘ‿ʘ 參考資料 How to Exit Vim – Vim Save and Quit Command Tutorial","link":"/20231103/vim-command-leave-edit-mode/"},{"title":"踩雷系列：在 Vue3 中怎麼使用 Vue I18n 取得陣列和物件的值？","text":"上週在開發公司專案時有遇到實作 i18n 功能的需求，結果在要拿取陣列裡面的資料時竟然遇到 bug 了，果不其然這是一個不會中斷更新的系列（只要我繼續當工程師）！下面一起來看看我踩了什麼雷然後怎麼解決的吧？ 遇到的問題在設定 vue i18n 的時候，我像以前一樣使用 vuei18n 提供給我的 $t 物件來取得我的翻譯檔案內的值，可是卻遇到取不到值的狀況。花了很多時間看一下是不是自己引入錯誤還是有其他的地方寫錯？結果都沒找到QQ最後在 vue i18n 的 repo 中看到了這個 Issue才知道自己是踩到版本不同的雷。 在 vue i18n 的 v8 版本（ for Vue2 ）跟 v9 版本（ for Vue3 ）裡面有一些比較重大的改變，其中一個就是包含要取得陣列內的資料時不能再使用 $t 物件，要視情況改成使用 $tm( Translation Messages) 物件並搭配 $rt( Runtime Translation ) 的動態 function 來取得值。 解決的方法使用 v9 版本新提供的 $tm 物件來取得陣列資料內的值 123const { t, tm } = useI18n({ useScope: 'global' })const partnerTypes: PartnerTypeList = tm('pages.Partners.partnerTypes')const allPartnerLists: PartnersList = tm('pages.Partners.partnersList') 最後的結語因為這次的踩雷剛好發現 v8 和 v9 版本有些寫法上的差異和改變，算是額外的學習機會。不過最近有一個蠻深刻的體悟，就是官方文件的重要性然後對於套件的熟悉度真的都會很大程度的影響我們的開發速度，希望自己能夠更熟悉這些工具同時培養專案經驗！ 那我們下次見ʘ‿ʘ 參考資料 Translation API return value How to Translate Vue i18n of v-for data Array of String 在你的專案中導入多國語系! 簡單介紹Vue-i18n基礎使用! breaking change: Can’t use nested arrays or arrays of objects needed for Page content or Language list","link":"/20231129/vuei18n-array-value-tm-t/"},{"title":"Element Plus 的 Cascader 長得不一樣？解決 el-cascader 無資料時的樣式變更問題","text":"踩雷系列全部的題材保證都是本人親自踩過的，希望各位如果剛好不幸遇到的話也能夠幸運的找到我的這篇文章幫你解惑！ 事件經過最近要把公司的 Vue 2 專案升級到 Vue 3 ，所以 Element UI 也理所當然的要跟著一起升級到 Element UI Plus 的。剛好在一個頁面裡面有用到 Element UI Plus 的 cascader 元件，元件內的選項是透過 API fetch 得到的，所以會出現在某些選項的 list 裡面是沒有資料的狀況，結果就這樣踩到新的雷了？ 踩到的雷在點擊了一個沒有子項目資料的父層選項時沒有在子選項的區塊顯示原本 Element UI 內建的 No data 的文字，而是可以直接選擇到該父層的選項。第一個念頭是：這個升級不太可能就這樣把原本設計的樣式直接換掉吧？ 結果在主管的幫助下確實發現了 Element UI Plus 並沒有將原本的顯示功能移除掉，只是變成一個新的屬性設定了！ 解決方法後來在官方文件（對！又是官方文件）看到了新增的一個屬性 leaf 可以設定該層級的選項是否可以被選取，所以當你在該物件內多寫了一個 leaf: false 時，就可以重現原本 Element UI 內的 No data 的行為了。 後記後來發現很多雷其實都是因為自己不熟悉套件或是語法的原因造成的，不過我覺得這次的踩雷有讓我學會一件事情，就是不管怎樣官方文件要先研究。 因為在遇到這個問題時，我第一個念頭是先 google 和找 StackOverflow 看有沒有人遇到跟我一樣的狀況，甚至下一步也是轉頭找 ChatGPT 問問看怎麼解決？但其實發展成熟的套件和框架基本上文件都會非常齊全，甚至有像 playground 這樣的線上編輯器讓你試著用用看的。 所以下次我會先把官方文件先好好看過一遍，如果確定沒有任何解決方案的時候我再去找外部的資源吧！ 那我們下次見ʘ‿ʘ 參考資料Element Plus - Cascader","link":"/20231221/elementui-plus-cascader-settings-nodata-style/"},{"title":"Vue.js 中的 v-for... in 和 v-for... of 兩者的使用情境","text":"有天公司前端團隊在幫我 code review 時第一次知道原來 Vue.js 內的指令 v-for 其實有不同的寫法，這邊想做一個紀錄順便跟大家分享一個這個對我來說算蠻新鮮的資訊。 v-for Render the element or template block multiple times based on the source data. 根據官方文件的內容可以知道，v-for 這個指令會根據我們所提供的原始資料數量決定要執行渲染的次數。其實光看指令的名稱包含了 for 這個單字就蠻容易聯想到它的功能或許會跟迴圈有相關，不過我一直以來都是以官方文件提供的這個寫法來做開發： 123&lt;div v-for=&quot;item in items&quot;&gt; {{ item.text }}&lt;/div&gt; 通常我用到 v-for 這個指令的時候都是我有陣列的資料需要去做渲染的需求，像是 Table 的列表或是要顯示相同但多張的 card 元件等。 兩種寫法的差異先說結論：兩種寫法的結果是一樣的，沒有差別。但為什麼還要拿出來討論甚至做筆記呢？ 因為這次會知道新的寫法是剛好在公司重構專案時遇到一個需要迭代的 Table ，裡面有物件也有陣列的資料格式。我像以前一樣全部都使用 v-for... in 這個寫法，結果在 code review 上得到一個 feedback ：如果迭代的資料類型是陣列的話可以改成 v-for... of 的寫法，這樣會讓團隊其他的人又或者是以後要來維護這個專案的開發人員能夠知道這邊渲染的格式會是一個陣列。 123&lt;div v-for=&quot;item of array&quot;&gt; {{ item.text }}&lt;/div&gt; 另外，其實在官方文件中也有特別提到如果要迭代的內容是陣列的話，改用 v-for... of 的話也會比較貼近 JavaScript 原本的語法 for ...of 。換句話說， v-for... in 這個寫法也會更貼近 JavaScript 原生的語法 for ...in 的形式，會更為適合用在迭代物件屬性的值時拿來使用。 感想這一年來在工作上多了許多跟他人協作開發的機會，慢慢體會到這些看似很細微的東西其實都有蠻大程度會影響到整個團隊的開發效率和溝通成本。就像是前端主管常跟我們說的，程式碼不是要用多冷門的語法或是多精簡的方式才是最好的，應該是要能夠清楚地表達出這段程式碼要完成的功能和邏輯，以及能讓不同程度的工程師都理解這邊要解決的問題是什麼？所以往後會在這些地方多留心，也期許自己能夠更細緻的處裡這些程式碼。那我們下次見ʘ‿ʘ 參考資料 List Rendering - Vue.js v-for of 与 v-for in 的的区别 JS-for…in 與 for…of 的差別","link":"/20240108/vuejs-vfor-vforin-vforof-difference-framework/"},{"title":"怎麼用 Tailwind CSS 設定群組樣式？複製貼上的瀏覽器原生方法","text":"每週用日記形式紀錄平日上班之餘鎖接觸到的新技術或是工具。順便分享給剛好看到的你！ 今日重點今天要分享的事情有兩個： tailwindcss 的樣式和 JavaScript 在瀏覽器上進行複製貼上的原生方法。 tailwindcss 群組樣式設定在 tailwindcss 裡面，如果你要設定一個組件的整個樣式的話，你可以使用 group- 前綴詞，這樣就可以把整個區塊或是元件內用同樣的條件判斷式來調整樣式。 1234567&lt;a href=&quot;#&quot; class=&quot;group block max-w-xs mx-auto rounded-lg p-6 bg-white ring-1 ring-slate-900/5 shadow-lg space-y-3 hover:bg-sky-500 hover:ring-sky-500&quot;&gt; &lt;div class=&quot;flex items-center space-x-3&quot;&gt; &lt;svg class=&quot;h-6 w-6 stroke-sky-500 group-hover:stroke-white&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot;&gt;&lt;!-- ... --&gt;&lt;/svg&gt; &lt;h3 class=&quot;text-slate-900 group-hover:text-white text-sm font-semibold&quot;&gt;New project&lt;/h3&gt; &lt;/div&gt; &lt;p class=&quot;text-slate-500 group-hover:text-white text-sm&quot;&gt;Create a new project from a variety of starting templates.&lt;/p&gt;&lt;/a&gt; JS 原生複製貼上方法1navigator.clipboard.writeText() 第一次因為產品需求而知道這個功能，覺得挺方便的！想說做個紀錄，順便分享給大家。 以上就是今天的內容啦！那我們下次見ʘ‿ʘ 參考資料 Styling based on parent state (group-{modifier}) Clipboard: writeText() method","link":"/20240125/tailwind-group-style-js-copy-paste-personal-log/"},{"title":"TypeHero Challenges 記錄： Generic Type Constraints","text":"TypeHero 是一個提供給工程師們練習 TypeScript 的開源平台，獻給一直想要學 TypeScript 卻觀望很久都沒有行動的你，歡迎一起來練習 TypeHero 變成 TypeScript 大師ㄅ！ 練習題目根據題目所提供的 Test 條件，去設定各個 type 該要帶入的值 1234type AllowString = unknown;type AllowNumber = unknown;type CreateLogger = unknown; 解法1234567type AllowString&lt;T extends string&gt; = T;type AllowNumber&lt;T extends number&gt; = T;type CreateLogger&lt;T extends (a: number) =&gt; void&gt; = { log: T; exit: () =&gt; void;}; 學習記錄這邊除了滿足題目的需求（通過 test）之外，有發現其他人提供的 solution 裡面包含了這些 type 或 function 實際應用的例子，所以才想說來記錄一下寫題目的過程。這邊會提供題目請我們撰寫的 type CreateLogger 來做應用： 12345678910111213type LogFunction = (a:number) =&gt; void;const logger: CreateLogger&lt;LogFunction&gt; = { log: (num) =&gt; { console.log(num); }, exit: () =&gt; { console.log(&quot;Exiting logger&quot;); }}logger.log(2020); // 2020logger.exit(); // Exiting logger 參考資料 TypeHero","link":"/20240130/typehero-typescript-beginner-challenges-generic-type-constraints/"},{"title":"Kata Practice - Sum Arrays (JavaScript)","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Write a function that takes an array of numbers and returns the sum of the numbers. The numbers can be negative or non-integer. If the array does not contain any numbers then you should return 0. 自己的解法123456789function sum (numbers) { &quot;use strict&quot;; if(numbers === []){ return 0 } else{ return numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue,0) }}; 解題脈絡題目有特別提到當陣列沒有給予任何的 number 時，需要返回 0 這個值。所以我先寫了 if… else 的條件式，如果陣列內沒有給予任何 number 就返回 0 ，剩餘的情況就會是陣列內有給予 number 的狀況，這時候再使用 reduce 這個陣列的方法將陣列內的所有數字做一個加總。 其他人的解法123function sum(numbers) { return numbers.reduce((a, b) =&gt; a + b, 0);} 選擇記錄這個解法的原因知道有 reduce 這個方法但沒有用的像解答一樣精簡，reduce 這個 array methods 最後已經會有一個預設值了，這樣代表當我今天傳入這個 sum 函式的 numbers 沒有包含任何的數字時，它就會是預設值 0 了。 觀念釐清感覺有些東西都多想了一些，所以繞了一圈。不過看了別人的解法就會發現自己多做了一些額外且不必要的處理，這樣代表我還有蠻大的進步空間的！ 那我們就下次見ʘ‿ʘ","link":"/20240324/codewars-kata-javascript-practice-sum-arrays/"},{"title":"Kata Practice - Find the smallest integer in the array (JavaScript)","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Given an array of integers your solution should find the smallest integer. For example: Given [34, 15, 88, 2] your solution will return 2 Given [34, -345, -1, 100] your solution will return -345 You can assume, for the purpose of this kata, that the supplied array will not be empty. 自己的解法12345class SmallestIntegerFinder { findSmallestInt(args) { return Math.min(...args) }} 解題脈絡直接 Google 找尋有沒有任何方法可以找尋一個陣列中的最小值，於是看到的 Math.min 這個方法。有點無趣的解法，不過算是淺顯易懂且直接的一個方式。 其他人的解法12345class SmallestIntegerFinder { findSmallestInt(args) { return args.sort((a,b)=&gt;a-b)[0]; }} 選擇記錄這個解法的原因我喜歡這個人先使用了陣列的 sort 方法將所傳進來的陣列先進行由小到大的排序，最後再選取重新整理順序的陣列內第一個的值就會是題目所要求的最小整數了！ 觀念釐清今天第一次有那種原來就算自己寫出最佳寫法好像也沒什麼的感覺，因為看到別人的解法還有下面的討論串你就會發現，要達成題目所要求的結果其實真的不只有那幾種常見的解法。有時候透過別人提交的答案你還會發現一些以前沒有的思考方式和解題思維，真的挺不錯的！ 那我們就下次見ʘ‿ʘ","link":"/20240326/codewars-kata-javascript-practice-find-the-smallest-interger-in-the-array/"},{"title":"Kata Practice - Reversed Strings (JavaScript)","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Complete the solution so that it reverses the string passed into it. 12'world' =&gt; 'dlrow''word' =&gt; 'drow' 自己的解法123function solution(str){ return str.split(&quot;&quot;).reverse().join('');} 解題脈絡昨天參考同事練習 Kata 的過程，他是先把要處理的步驟想好並且列出來後就按照剛才想的流程來解題。所以我試著把我看到題目後想到的處理順序列出來，大致是這樣： 有想到 reverse 這個陣列方法，但要先將字串分隔開並放在陣列裡 分隔開後使用 reverse 將順序顛倒 顛倒後因為是分開的狀態，所以要再把它們組合在一起最後我的實作就是先用到 split 的方法將字串個別拆開，拆開後就可以用我想到的 reverse 陣列方法來翻轉順序，最後使用 join 把它們組合回去。 其他人的解法1const solution = s =&gt; [...s].reverse().join('') 選擇記錄這個解法的原因這邊我覺得也是一個很不錯的解法，首先是我忘記可以用箭頭函式來簡化，這樣就不用寫 return 了。再來就是直接用展開運算子 Spread Operator 將字串分隔開來，我個人是比較喜歡這個做法，有種更簡潔的感覺。 觀念釐清跟昨天那題一樣，今天的 Kata 也是寫了一個 Best Practice 的答案，但老實說大多數人認為的最佳解也不一定是你會欣賞或是習慣的方式，所以大家可以自己評估一下順便多看看別人的思考邏輯和順序也是不錯的！不過我之後可能會想要知道這些解法是不是有效能跟記憶體上使用的差異？先筆記起來 那我們就下次見ʘ‿ʘ","link":"/20240327/codewars-kata-javascript-practice-reversed-strings/"},{"title":"Kata Practice - Set Alarm (JavaScript)","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Write a function named setAlarm/set_alarm/set-alarm/setalarm (depending on language) which receives two parameters. The first parameter, employed, is true whenever you are employed and the second parameter, vacation is true whenever you are on vacation. The function should return true if you are employed and not on vacation (because these are the circumstances under which you need to set an alarm). It should return false otherwise. Examples: 自己的解法123456function setAlarm(employed, vacation){ if (employed === true &amp;&amp; vacation === false) { return true; } return false;} 解題脈絡針對題目給的條件去設定 if else 的條件式，然後依照不同的情境 return 布林值。 其他人的解法1const setAlarm = (employed, vacation) =&gt; employed &amp;&amp; !vacation; 選擇記錄這個解法的原因有記得使用箭頭函式，這樣就不用再多寫 return 了。最後的直接根據傳入的參數直接呈現原來的布林值就好，更簡潔。 觀念釐清我自己在寫完這題 Kata 的時候就覺得好像有更簡潔的寫法，只是當下沒有想到其他的方法。想說可以去看討論區的回覆，看看其他人的解法。 那我們就下次見ʘ‿ʘ","link":"/20240402/codewars-kata-javascript-practice-set-alarm/"},{"title":"Kata Practice - Abbreviate a two word name (JavaScript)","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Write a function to convert a name into initials. This kata strictly takes two words with one space in between them.The output should be two capital letters with a dot separating them.It should look like this: Sam Harris =&gt; S.Hpatrick feeney =&gt; P.F 自己的解法12345function abbrevName(name){ const words = name.trim().split(' '); const initials = words.map(word =&gt; word.charAt(0).toUpperCase()); return initials.join('.');} 解題脈絡其實我原本想不到要怎麼解，所以先查了一些字串處理的文章。最後決定先把名字拆成兩個陣列的值，再用 chartAt 的字串處理方式取出每一個單字的第一個 character 後，使用 join 將取出的字串用 . 合併。 其他人的解法123function abbrevName(name){ return name.split(' ').map(i =&gt; i[0].toUpperCase()).join('.')} 選擇記錄這個解法的原因其實是和我自己的解法一模一樣，只是它沒有使用額外的變數來宣告並儲存處理後的值，而是直接將所有的陣列處理都用在 name 這個參數上，更簡潔也更清楚 觀念釐清其實除了上面的解法之外，也有看到一個很有趣的解法： 1const abbrevName = name =&gt; name.match(/\\b\\w/g).join('.').toUpperCase() 這是使用了正規表達式的一個解法，其中： \\b 代表單詞邊界(word boundary) \\w 代表匹配任意單詞字符(包括字母、數字和下劃線) g 是一個修飾符,代表全局(global)模式,讓正規表達式可以匹配字串中的所有單詞字符。因此 name.match(/\\b\\w/g) 將會把名字字串中每個單詞的第一個 character 作為單獨的元素提取出來,並組成一個數組。例如,對於 “Sam Harris”,結果將是 [&quot;S&quot;, &quot;H&quot;]。不過我沒有選擇這個為最佳解的原因是，透過 Array 的處理方式好像相較比較好閱讀，也更清楚知道這個 function 是在做什麼樣的操作？所以最後才沒有選擇這個使用正規表達式的解答。 那我們就下次見囉ʘ‿ʘ","link":"/20240408/codewars-kata-javascript-practice-abbreviate-a-two-word-name/"},{"title":"Kata Practice - Simple Multiplication (JavaScript)","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目This kata is about multiplying a given number by eight if it is an even number and by nine otherwise. 自己的解法123456function simpleMultiplication(number) { if(number % 2 === 0){ return number*8 } return number*9} 解題脈絡很直觀的直接用基本的運算子做處理，如果能被 2 整除就是雙數；反之，就是奇數了。 其他人的解法123function simpleMultiplication(n) { return n * (n % 2 ? 9 : 8);} 選擇記錄這個解法的原因直接使用三元條件運算子來判斷 number 要乘以的數字是哪個？真的是 Clever 到不行又簡潔易懂！ 觀念釐清我發現寫 Kata 到現在之後，在點擊 submit 的按鈕的時候會有一種很興奮的感覺，因為你不知道等下會看到什麼神奇或是你從來沒有想過的解法！像今天這個我就覺得不僅邏輯有呈現出來，而且又很乾淨利落。希望自己也能慢慢用這種思維來解題～ 那我們就下次見ʘ‿ʘ","link":"/20240410/codewars-kata-javascript-practice-simple-multiplication/"},{"title":"Kata Practice - Sum Mixed Array (JavaScript)","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目Given an array of integers as strings and numbers, return the sum of the array values as if all were numbers. Return your answer as a number. 自己的解法12345678function sumMix(x){ const numberArray = x.map((e)=&gt;{ return parseInt(e) }) return sumTotal = numberArray.reduce((accu,current) =&gt; accu + current , 0 )} 解題脈絡先把每一個陣列的值都轉換成 Number 後，在使用 reduce 這個陣列法法將每一個陣列內的值相加，最後在 return 經過相加的值。 其他人的解法123function sumMix(x){ return x.reduce((a, b) =&gt; a + +b,0)} 選擇記錄這個解法的原因我在這個 function 的上面有多做了一個 string to number 的處理，不過我在 solution 的地方看到一個我之前不知道的運算子 + ，它的功能就是將你指定的值轉變成 number 的型別，所以運用這個 unary operators 就可以將字串轉型別的這個步驟完成了。 觀念釐清學到一個新的 unary operators 之外，也發現自己的寫法好像比較會逐步地將要處理的步驟都寫出來，所以跟 solution 裡面看到的最佳解比起來貌似都多了一些不必要的步驟 XD看來要繼續練習一些 kata 囉！ 那我們就下次見ʘ‿ʘ 參考資料 Unary negation","link":"/20240411/codewars-kata-javascript-practice-sum-mixed-array/"},{"title":"Kata Practice - Remove First and Last Character (JavaScript)","text":"這個系列會把自己練習過的 Kata 題目記錄下來，希望除了記錄的性質以外也能夠觀察自己撰寫程式邏輯的進化過程。如果有幸看到這邊的話也可以參考一下，再到 Codewars 的網站註冊一個帳號試著玩看看，自己蠻喜歡整個網站的得分和排行榜設定，會讓人越寫越有成就感喔！ 題目It’s pretty straightforward. Your goal is to create a function that removes the first and last characters of a string. You’re given one parameter, the original string. You don’t have to worry about strings with less than two characters. 自己的解法1234function removeChar(str){ const splitArray = str.split('') return splitArray.slice(1,splitArray.length-1).join('')}; 解題脈絡先用 split 把字串都拆開後，在用移除的 slice function 來移除陣列中第一個值以及最後一個值。最後一個值的計算是使用陣列長度 length 的值減 1 之後得到的。 其他人的解法1const removeChar = str =&gt; str.slice(1,-1) 選擇記錄這個解法的原因這邊是直接只用原生的 JavaScript 的 array 方法 slice 處理，第二個參數直接帶入 -1 後就可以移除掉最後一個值。 觀念釐清很明顯的這個練習就體現出自己對陣列的處理方式還是真的很不熟！而且我覺得如果我完全都不知道這個 slice 的方法就算了，更慘的是我明明用了結果來不曉得可以直接帶入負數的值從後面移除指定的 item ，根本不需要計算該陣列的資料有多長 QQ 不過每一次的練習都是讓我更熟悉陣列的處理還有方法，所以真的要持續練習呀！那我們就下次見ʘ‿ʘ","link":"/20240416/codewars-kata-javascript-practice-remove-first-and-last-character/"}],"tags":[{"name":"Diary","slug":"Diary","link":"/tags/Diary/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"PersonalStuff","slug":"PersonalStuff","link":"/tags/PersonalStuff/"},{"name":"GoogleExtension","slug":"GoogleExtension","link":"/tags/GoogleExtension/"},{"name":"WebSecurity","slug":"WebSecurity","link":"/tags/WebSecurity/"},{"name":"E2E","slug":"E2E","link":"/tags/E2E/"},{"name":"Testing","slug":"Testing","link":"/tags/Testing/"},{"name":"UnitTest","slug":"UnitTest","link":"/tags/UnitTest/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"CodeCamp","slug":"CodeCamp","link":"/tags/CodeCamp/"},{"name":"Microsoft","slug":"Microsoft","link":"/tags/Microsoft/"},{"name":"Challenge","slug":"Challenge","link":"/tags/Challenge/"},{"name":"Certification","slug":"Certification","link":"/tags/Certification/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Debounce","slug":"Debounce","link":"/tags/Debounce/"},{"name":"Thorttle","slug":"Thorttle","link":"/tags/Thorttle/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"Swagger","slug":"Swagger","link":"/tags/Swagger/"},{"name":"BlankSpace","slug":"BlankSpace","link":"/tags/BlankSpace/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"空白","slug":"空白","link":"/tags/%E7%A9%BA%E7%99%BD/"},{"name":"Hexadecimal","slug":"Hexadecimal","link":"/tags/Hexadecimal/"},{"name":"Hexi","slug":"Hexi","link":"/tags/Hexi/"},{"name":"NumberingSystem","slug":"NumberingSystem","link":"/tags/NumberingSystem/"},{"name":"16進位","slug":"16進位","link":"/tags/16%E9%80%B2%E4%BD%8D/"},{"name":"CS","slug":"CS","link":"/tags/CS/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Style","slug":"Style","link":"/tags/Style/"},{"name":"Blogger","slug":"Blogger","link":"/tags/Blogger/"},{"name":"Kata","slug":"Kata","link":"/tags/Kata/"},{"name":"Codewars","slug":"Codewars","link":"/tags/Codewars/"},{"name":"KataPractice","slug":"KataPractice","link":"/tags/KataPractice/"},{"name":"Fundamentals","slug":"Fundamentals","link":"/tags/Fundamentals/"},{"name":"React.js","slug":"React-js","link":"/tags/React-js/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"},{"name":"Learning","slug":"Learning","link":"/tags/Learning/"},{"name":"FrontEnd","slug":"FrontEnd","link":"/tags/FrontEnd/"},{"name":"Note","slug":"Note","link":"/tags/Note/"},{"name":"Agile","slug":"Agile","link":"/tags/Agile/"},{"name":"Scrum","slug":"Scrum","link":"/tags/Scrum/"},{"name":"ScrumMaster","slug":"ScrumMaster","link":"/tags/ScrumMaster/"},{"name":"ProductOwner","slug":"ProductOwner","link":"/tags/ProductOwner/"},{"name":"DevelopementTeam","slug":"DevelopementTeam","link":"/tags/DevelopementTeam/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"VueDirective","slug":"VueDirective","link":"/tags/VueDirective/"},{"name":"事件綁定","slug":"事件綁定","link":"/tags/%E4%BA%8B%E4%BB%B6%E7%B6%81%E5%AE%9A/"},{"name":"指令","slug":"指令","link":"/tags/%E6%8C%87%E4%BB%A4/"},{"name":"v-on","slug":"v-on","link":"/tags/v-on/"},{"name":"WebDevelopment","slug":"WebDevelopment","link":"/tags/WebDevelopment/"},{"name":"GraphQL","slug":"GraphQL","link":"/tags/GraphQL/"},{"name":"RESTful","slug":"RESTful","link":"/tags/RESTful/"},{"name":"Design","slug":"Design","link":"/tags/Design/"},{"name":"NPM","slug":"NPM","link":"/tags/NPM/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"Version","slug":"Version","link":"/tags/Version/"},{"name":"Solution","slug":"Solution","link":"/tags/Solution/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"extension","slug":"extension","link":"/tags/extension/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"Jumpy","slug":"Jumpy","link":"/tags/Jumpy/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"ViewportUnit","slug":"ViewportUnit","link":"/tags/ViewportUnit/"},{"name":"svh","slug":"svh","link":"/tags/svh/"},{"name":"lvh","slug":"lvh","link":"/tags/lvh/"},{"name":"dvh","slug":"dvh","link":"/tags/dvh/"},{"name":"freeCodeCamp","slug":"freeCodeCamp","link":"/tags/freeCodeCamp/"},{"name":"DesignPattern","slug":"DesignPattern","link":"/tags/DesignPattern/"},{"name":"GoF","slug":"GoF","link":"/tags/GoF/"},{"name":"GangofFour","slug":"GangofFour","link":"/tags/GangofFour/"},{"name":"Principle","slug":"Principle","link":"/tags/Principle/"},{"name":"Pattern","slug":"Pattern","link":"/tags/Pattern/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"Command","slug":"Command","link":"/tags/Command/"},{"name":"MultipleSelect","slug":"MultipleSelect","link":"/tags/MultipleSelect/"},{"name":"Methods","slug":"Methods","link":"/tags/Methods/"},{"name":"Exit","slug":"Exit","link":"/tags/Exit/"},{"name":"Save","slug":"Save","link":"/tags/Save/"},{"name":"Quit","slug":"Quit","link":"/tags/Quit/"},{"name":"Vue3","slug":"Vue3","link":"/tags/Vue3/"},{"name":"I18n","slug":"I18n","link":"/tags/I18n/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Object","slug":"Object","link":"/tags/Object/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"ElementPlus","slug":"ElementPlus","link":"/tags/ElementPlus/"},{"name":"Cascader","slug":"Cascader","link":"/tags/Cascader/"},{"name":"VueJS","slug":"VueJS","link":"/tags/VueJS/"},{"name":"Settings","slug":"Settings","link":"/tags/Settings/"},{"name":"v-for","slug":"v-for","link":"/tags/v-for/"},{"name":"迴圈","slug":"迴圈","link":"/tags/%E8%BF%B4%E5%9C%88/"},{"name":"列表渲染","slug":"列表渲染","link":"/tags/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"},{"name":"GroupStyle","slug":"GroupStyle","link":"/tags/GroupStyle/"},{"name":"CopyAndPaste","slug":"CopyAndPaste","link":"/tags/CopyAndPaste/"},{"name":"tailwindcss","slug":"tailwindcss","link":"/tags/tailwindcss/"},{"name":"TypeHero","slug":"TypeHero","link":"/tags/TypeHero/"},{"name":"Challenges","slug":"Challenges","link":"/tags/Challenges/"},{"name":"GenericTypeConstraints","slug":"GenericTypeConstraints","link":"/tags/GenericTypeConstraints/"},{"name":"Beginner","slug":"Beginner","link":"/tags/Beginner/"}],"categories":[{"name":"SuoChan&#39;s Log","slug":"SuoChan-s-Log","link":"/categories/SuoChan-s-Log/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Debug Series","slug":"Debug-Series","link":"/categories/Debug-Series/"},{"name":"CS Series","slug":"CS-Series","link":"/categories/CS-Series/"},{"name":"React.js 30 Days","slug":"React-js-30-Days","link":"/categories/React-js-30-Days/"},{"name":"Scrum","slug":"Scrum","link":"/categories/Scrum/"},{"name":"Vue.js","slug":"Vue-js","link":"/categories/Vue-js/"},{"name":"C# Challenge","slug":"C-Challenge","link":"/categories/C-Challenge/"},{"name":"Web Development","slug":"Web-Development","link":"/categories/Web-Development/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"Vim","slug":"Vim","link":"/categories/Vim/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"Kata Practice JavaScript","slug":"Kata-Practice-JavaScript","link":"/categories/Kata-Practice-JavaScript/"},{"name":"Kata Practice C#","slug":"Kata-Practice-C","link":"/categories/Kata-Practice-C/"}],"pages":[{"title":"","text":"google-site-verification: google2e6edbdffdf9e909.html","link":"/google2e6edbdffdf9e909.html"}]}